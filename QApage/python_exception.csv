Error,설명,
input,"사용자로부터 키보드로 입력을 받는 Python 내장 함수입니다.
    이름 입력 혹은 변수 입력 등에 활용됩니다.","input_str = input() # input : 'Hello World!'
print('입력값' : input_str)

결과 값 : 'Hello World!"
split,"문자열을 특정한 구분자를 기준으로 분리하여 리스트로 반환하는 Python 문자열 매서드입니다.
    구분자는 기본적으로 공백으로 설정되어 있으며 쉼표나 탭 등의 임의의 문자를 설정할 수 있습니다.","sentence = 'Hello World!'
print(sentence.split())

결과 값 : ['Hello', 'World!']


print(sentence.split('l'))

결과 값 : ['He', '', 'o Wor', 'd!']"
slice,"Python에서 slice는 시퀀스 객체(문자열, 리스트, 튜플 등)에서 특정 범위의 요소를 추출하는 방법입니다.
    slice는 객체의 일부분을 선택하여 새로운 시퀀스 객체를 생성합니다.
    slice는 [num : num](num : integer) 형식으로 사용됩니다.","sentence = 'Hello World!'
print(sentence[3:])

결과 값 : 'lo World!'
"
if,"if문은 조건에 따라서 특정 코드 블록을 실행하거나 건너뛰는 데 사용되는 제어문입니다.
    조건이 True일 경우 해당 코드 블록이 실행되며 조건이 False인 경우에는 코드 블록이 건너 뛰어집니다.
    if문은 단독으로 사용될 수도 있고 else나 elif(else if의 줄임말)와 함께 사용될 수 있습니다.
    else문는 조건이 False인 경우 실행되고 elif문은 추가적인 조건을 검사합니다.","x = 10
if x > 10:
    print('x는 10보다 큽니다.')
elif x < 10:
    print(""x는 10보다 작습니다."")
else:
    print(""x는 10입니다."")
"
while,"while문은 조건이 참일 경우 코드 블록을 반복 실행하는 Python 제어문입니다.
            조건이 참인 동안 계속해서 반복되므로 조건을 적절하게 설정하여 무한 루프에 빠지지 않도록 주의해야 합니다.
            무한 루프를 피하기 위해 반복문 안에서 조건을 넣거나 break 문을 사용하여 반복을 중단시킬 수 있습니다.","# while문 예시
num = 1
while num < 4:
    print(num)
    num += 1

# while 문이 무한루프가 되는 경우
num = 1
while True:
    print(num)
    num += 1
"
open,"open()은 Python에서 파일을 열기 위해 사용되는 내장 함수입니다.
            open() 함수를 사용하여 파일을 열면 파일 객체를 반환하고 이를 통해 읽기 쓰기 등의 작업을 수행할 수 있습니다.
            open() 함수의 구조는 다음과 같습니다.

            # open(file    mode    encoding)
            - file : 파일의 경로 또는 파일명을 나타냅니다.
            - mode : 수행할 작업을 나타내는 문자열입니다.
                - r : 읽기 모드로 파일을 엽니다.
                - w : 쓰기 모드로 파일을 엽니다.
                - a : 추가 모드로 파일을 엽니다. 파일의 끝에 내용을 추가할 때 사용됩니다.
                - x : 베타적 생성 모드로 파일을 엽니다. 파일이 이미 존재하는 경우 실패합니다.
            - encoding : 파일의 인코딩을 지정합니다.

            open() 함수를 통한 작업 후 close() 매서드를 호출하여 파일을 닫을 수 있습니다.
            추가적으로, 파일을 열 때 with 문을 사용하면 파일을 자동으로 닫을 수 있습니다.
            ","# example 1

file = open('example.txt', 'r', encoding='UTF-8')
content = file.read()
print(content)
file.close()

# example 2

with open('example.txt', 'r') as file:
    content = file.read()
    print(content)

"
readline,"open()을 통해 파일을 열고 readline() 혹은 readlines()로 파일에서 데이터를 읽을 수 있습니다.
readline() 매서드는 파일에서 한 줄씩 데이터를 읽어 올 때 사용됩니다.
readlines() 매서드는 모든 줄을 읽어와 리스트로 반환합니다.
","file = open('example.txt', 'r')

line = file.readline()

lines = file.readlines()
"
enumerate,"enumerate() 함수는 Python에서 반복 가능한(iterable)객체를 순회하면서 각 요소의 인덱스와 값을 함께 반환하는 내장 함수입니다.
enumerate() 함수를 사용하면 index와 value를 쌍으로 처리 가능하여 반복문에서 유용하게 활용됩니다.
","fruits = ['apple', 'banana', 'orange']

for index, fruit in enumerate(fruits):
    print(index, fruit)

    
결과값 : 
0 apple
1 banana
2 orange
"
append,"append()는 Python 리스트(list) 객체에 새로운 요소를 추가하는데 사용되는 내장 메서드입니다. 
append() 메서드를 호출하면 리스트의 끝에 주어진 값을 추가합니다.
","fruits = ['apple', 'banana', 'orange']

fruits.append('grape')
print(fruits)

결과값 : 
['apple', 'banana', 'orange', 'grape']
"
for,"for문은 Python에서 반복을 수행하는 루프(loop)구문입니다.
for문은 시퀀스 객체나 이터러블 객체의 요소를 하나씩 순회하면서 반복 작업을 수행합니다.
","fruits = ['apple', 'banana', 'orange']

for fruit in fruits:
    print(fruit)

결과값 : 
apple
banana
orange
"
membership operator,"membership operator는 Python에서 특정 요소가 시퀀스 객체 또는 컬렉션에 속하는지를 확인하는 연산자입니다.
Python에서는 'in'과 'not in' 두 가지의 membership operator가 제공됩니다.
'in' 연산자는 특정 요소가 속해있다면 True를 속해있지 않다면 False를 반환합니다.
'not in' 연산자는 특정 요소가 속해있다면 False를 속해있지 않다면 True를 반환합니다.
","fruits = ['apple', 'banana', 'orange']
print('apple' in fruits)

결과값 : 
True
"
type,"type()은 Python 내장 함수이며 주어진 객체의 자료형을 반환합니다.
type() 함수를 사용하여 객체의 자료형을 확인할 수 있습니다.
","x = 10
y = 'Hello'
z = [1, 2, 3]

print(type(x))
print(type(y))
print(type(z))

결과값 : 
<class 'int'>
<class 'str'>
<class 'list'>
"
string,"문자의 시퀀스로 이루어진 자료형입니다.
문자열은 작은 따옴표(')나 큰 다옴표("")로 둘러싸여 있습니다.
","print(type('Hello World!') == str)

결과값:
True
"
inteager,"정수를 나타내는 자료형입니다.
","print(type(10) == int)
print(type(-5) == int)

결과값:
True
True
"
list,"여러 개의 요소를 순서대로 담고 있는 변경 가능한 자료형입니다. 대괄호([])로 요소들을 묶어 표현합니다.
","list_number = [1, 2, 3]
list_fruit = ['apple','banana','melon']
"
dictionary,"키와 값의 쌍으로 이루어진 자료형입니다. 중괄호({})를 사용하여 표현하며 각 키와 값은 콜론(:)으로 구분합니다. 
","{'name' : 'Yewon'}
"
float,"부동 소수점 숫자(=실수)를 나타내는 자료형입니다.
","print(type(3.14) == float)
print(type(-2.789123) == float)

결과값:
True
True
"
bool,"참(True) 또는 거짓(False) 값을 가지는 자료형입니다.
","True or False
"
tuple,"여러 개의 요소를 순서대로 담고 있는 변경 불가능한 자료형입니다. 
괄호(())로 요소들을 묶어 표현하거나 괄호 없이 쉼표로 요소들을 구분하여 표현합니다.
","(1, 2, 3)
"
set,"고유한 값들의 모임을 나타내는 자료형입니다. 중괄호({})나 set() 함수를 사용하여 표현합니다.
","{1, 2, 3}
set([4, 5, 6]
"
escape character,"
나 	 와 같은 역슬래시(\)와 특정 문자를 조합하여 특수한 동작을 수행하도록 하는 문자를 escape character라고 합니다.
자세한 내용은 각각의 의미는 다음과 같습니다.
\ (역슬래시): 역슬래시 자체를 나타냅니다.
' (작은 따옴표): 작은 따옴표를 나타냅니다.
"" (큰 따옴표): 큰 따옴표를 나타냅니다.

 (새 줄): 새 줄을 나타냅니다.
	 (탭): 탭 문자를 나타냅니다.
 (백스페이스): 백스페이스를 나타냅니다.
 (캐리지 리턴): 현재 라인의 처음으로 커서를 이동합니다.
 (폼 피드): 페이지 나누기를 나타냅니다.
 (수직 탭): 수직 탭을 나타냅니다.
","print('Hello
	World!')

결과값:
Hello
	World!
"
iterable,"Iterable(이터러블)은 Python에서 데이터의 집합을 순회할 수 있는 객체를 말합니다.
이터러블은 for 루프와 같은 반복문에서 사용할 수 있으며, 내장 함수인 iter()를 사용하여 이터레이터로 변환할 수 있습니다.",
sequence,"Sequence(시퀀스)는 Python에서 데이터의 순서가 있는 집합을 나타내는 추상 데이터 타입입니다.
시퀀스는 여러 개의 항목으로 이루어져 있으며, 각 항목은 순서대로 접근할 수 있습니다",
time,"time은 Python의 내장 모듈로서 시간과 관련된 기능을 제공합니다.
이 모듈을 사용하여 시간에 대한 정보를 얻거나 시간을 측정하고 제어할 수 있습니다.
아래는 time 모듈에서 제공하는 주요 함수들입니다.

1. time: 현재 시간을 Unix 시간(epoch time)으로 반환합니다. Unix 시간은 1970년 1월 1일 자정부터 경과한 초 단위 시간을 나타냅니다.
2. ctime: 주어진 Unix 시간을 사람이 읽기 쉬운 형식으로 변환하여 문자열로 반환합니다.
3. sleep: 주어진 시간(초 단위) 동안 프로그램을 일시 정지시킵니다.
4. perf_counter: 프로그램의 성능 측정을 위해 사용되는 시간을 반환합니다. 보다 정확한 시간 측정을 제공합니다.
5. strftime: 주어진 시간을 형식화된 문자열로 반환합니다. 형식 문자열을 사용하여 원하는 시간 형식을 지정할 수 있습니다.
6. strptime: 주어진 문자열을 시간으로 변환합니다. 형식 문자열을 사용하여 주어진 문자열을 특정한 시간 형식으로 해석합니다.",
def,"def는 Python에서 함수를 정의할 때 사용하는 키워드입니다.
def 키워드를 사용하여 함수를 정의하면 해당 함수의 이름, 매개변수, 실행 코드 등을 지정할 수 있습니다.
함수는 재사용 가능한 코드 블록으로, 특정 작업을 수행하기 위해 여러 번 호출될 수 있습니다.","def greet(name):
    message = f""Hello, {name}!""
    print(message)

greet(""John"")
결과값:
Hello, John!"
items,"items()는 Python의 딕셔너리(Dictionary) 객체에서 사용할 수 있는 메서드입니다.
items() 메서드는 딕셔너리의 키-값 쌍을 각각의 튜플로 구성된 리스트로 반환합니다.
이를 통해 딕셔너리의 모든 항목을 순회하면서 키와 값을 동시에 처리할 수 있습니다.","dogs = {'name' : 'yedong', 'age' : 5}
for key, value in dogs.items():
    print(f""{key}는(은) {value}이다."")

결과값:
name는(은) yedong이다.
age는(은) 5이다.
"
len,"len()은 Python의 내장 함수중 하나로, 주어진 시퀀스 또는 컬렉션의 요소 개수를 반환합니다.","numbers = [1, 2, 3, 4]
print(len(numbers))

결과값:
4"
min,"min()은 Python의 내장 함수 중 하나로, 주어진 시퀀스 또는 컬렉션에서 가장 작은 값을 반환합니다.","numbers = [1, 2, 3, 4]
print(min(numbers))

결과값:
1"
max,"max()는 Python의 내장 함수 중 하나로, 주어진 시퀀스 또는 컬렉션에서 가장 큰 값을 반환합니다.","numbers = [1, 2, 3, 4]
print(max(numbers))

결과값:
4"
range,"range()는 Python의 내장 함수 중 하나로, 연속된 정수들의 시퀀스를 생성하는 데 사용됩니다.
range()의 사용법은 다음과 같습니다.
1. range(stop)
2. range(start, stop)
3. range(start, stop, step)

stop: 생성된 시퀀스의 마지막 값(범위에 포함되지 않음)
start: 생성된 시퀀스의 첫 번째 값(범위에 포함됨), 기본값은 0
step: 인접한 값 사이의 간격(증가 값), 기본값은 1
","for i in range(0, 5, 2):
    print(i)

결과값:
0
2
4"
map,"map()은 Python의 내장 함수 중 하나로, 주어진 함수를 시퀀스나 반복 가능한 객체의 각 요소에 적용하여 새로운 시퀀스를 생성하는 데 사용됩니다.
각 요소에 함수를 적용하여 변환된 값을 반환하는 역할을 합니다.
map()의 사용법은 아래와 같습니다.

map(function, sequence)
function: 적용할 함수
sequence: 함수를 적용할 시퀀스 또는 반복 가능한 객체","def sum(num):
    return num + num

numbers = [1, 2, 3, 4, 5]
squared_numbers = map(sum, numbers)
print(list(squared_numbers))

결과값:
[2, 4, 6, 8, 10]"
lambda,"lambda는 Python에서 사용되는 '익명 함수'를 생성하기 위한 키워드입니다.
'익명 함수'는 이름이 없는 함수로, 한 번만 사용할 목적으로 간단한 함수를 정의할 때 주로 활용됩니다.
lambda의 구조는 다음과 같습니다.
lambda (매개변수): (함수)","add = lambda x, y: x+y
print(add(3,5))

결과값:
8"
sort,"sort()는 Python에서 리스트를 정렬하는 함수입니다.
비슷한 함수로 sorted()가 존재합니다.
sort()는 리스트 자체를 정렬하여 변경합니다. 따라서 원본 리스트가 변경됩니다.
기본적으로 오름차순으로 정렬됩니다.

sorted()는 리스트를 정렬한 새로운 리스트를 반환합니다. 따라서 원본 리스트가 변경되지 않습니다.
기본적으로 오름차순으로 정렬되며 'reverse=True'라는 매개변수를 지정하여 내림차순으로 정렬할 수 있습니다.
'key='매개변수를 활용하여 정렬 기준을 지정할 수 있습니다.","names = ['John', 'Alice', 'Yedong']
sorted_names = sorted(names, key=len)
print(sorted_names)

결과값:
['Yedong', 'Alice', 'John']
"
join,"join()은 문자열을 특정 구분자로 연결하는 Python의 문자열 메서드입니다.
join() 메서드를 사용하여 리스트나 이터러블 객체의 요소들을 하나의 문자열로 결합할 수 있습니다.","fruits = [""apple"", ""banana"", ""orange""]
result = "" "".join(fruits)
print(result)

결과값:
apple banana orange
"
zip,"zip()은 여러 개의 이터러블객체를 받아서 동일한 인덱스에 위치한 요소들을 튜플로 묶어주는 함수입니다.
각 이터러블 객체에서 동일한 위치에 있는 요소들을 묶어 튜플로 반환합니다.","names = [""Alice"", ""Bob"", ""Yedong""]
ages = [25, 30, 5]

result = zip(names, ages)
print(list(result))

결과값:
[('Alice', 25), ('Bob', 30), ('Yedong', 5)]
"
print,print()는 Python에서 화면에 출력하는 기능을 제공하는 내장 함수입니다.,"sentence = 'Hello, World!'
print('문장 : ', sentence)

결과값:
문장 : Hello, World!"
pop,pop()은 리스트에서 요소를 제거하고 반환하는 메서드입니다.,"dogs = ['happy', 'choco', 'yedong']
pop_dogs = dogs.pop(1)

print('pop dogs : ', pop_dogs)
print('left dogs : ', dogs)

결과값:
pop dogs :  choco
left dogs :  ['happy', 'yedong']
"
f-string,f-string은 문자열 안에 변수나 표현식을 쉽게 삽입할 수 있는 방법을 제공하는 Python 문법입니다.,"name = ""yedong""
age = 5
print(f""My dog's name is {name} and he is {age} years old"")

결과값 : My dog's name is yedong and he is 5 years old
"
raw string,"
raw string은 escape sequence를 해석하지 않고 그대로 문자열로 표현하는 특징을 갖고 있습니다.
","path = r""C:\Users\Username\Documents""
print(path)

결과값 : ""C:\Users\Username\Documents""
"
collections,"collections는 Python 내장 모듈로, 다양한 데이터 구조와 연관된 유용한 클래스와 함수를 제공합니다. 이 모듈을 사용하면 기본 데이터 구조에 비해 더 다양한 기능을 가진 자료구조를 쉽게 활용할 수 있습니다.
아래는 collections의 몇가지 주요 클래스입니다.

1. namedtuple: namedtuple은 튜플의 서브클래스로서, 필드에 이름을 부여하여 각 필드에 접근하기 쉽게 해줍니다. 필드 이름을 사용하여 튜플 요소에 접근할 수 있으며, 튜플처럼 불변성을 유지합니다.
2. deque: deque은 양쪽 끝에서 빠르게 삽입 및 삭제할 수 있는 큐(Queue)와 스택(Stack)의 기능을 모두 제공하는 덱(Deque)입니다. 큐나 스택으로 사용될 수 있으며, 큐의 연산과 스택의 연산을 모두 지원합니다.
3. Counter: Counter는 해시 가능한 객체들의 개수를 세는 데 사용됩니다. 리스트, 문자열, 딕셔너리 등 다양한 객체에서 요소의 개수를 쉽게 세고, 각 요소의 개수를 딕셔너리 형태로 반환합니다.
4. defaultdict: defaultdict는 딕셔너리의 서브클래스로서, 키(key)에 대한 디폴트 값을 지정할 수 있습니다. 키를 참조했을 때, 해당 키가 없으면 디폴트 값으로 지정된 데이터 타입의 빈 값이 반환됩니다.
5. OrderedDict: OrderedDict는 딕셔너리의 서브클래스로서, 요소들이 삽입된 순서를 기억합니다. 딕셔너리의 순서가 중요한 경우에 사용됩니다.",
namedtuple,"namedtuple은 Python의 collections 모듈에 있는 함수로서, 튜플과 같은 불변 데이터 구조를 생성하는 데 사용됩니다.
그러나 namedtuple은 일반적인 튜플과 달리 각 필드에 이름을 지정할 수 있습니다.
namedtuple은 다음과 같은 형식으로 사용됩니다

TypeName = namedtuple('TypeName', ['field1', 'field2', ...])","from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'city'])
person1 = Person('Alice', 25, 'New York')

print(person1.name)
print(person1.age)
print(person1.city)

결과값:
Alice
25
New York"
queue,"Queue는 Python의 queue 모듈에 있는 클래스로서, 멀티스레딩 환경에서 스레드 간에 안전하게 데이터를 교환하기 위한 자료구조를 제공합니다.
Queue는 스레드 간에 동기화된 큐(queue)를 구현하며, 스레드 간의 안전한 데이터 공유를 지원합니다.
put(item): 큐에 item을 추가합니다.
get(): 큐에서 항목을 제거하고 반환합니다.
empty(): 큐가 비어있는지 여부를 확인합니다. 비어있으면 True를 반환하고, 그렇지 않으면 False를 반환합니다.
qsize(): 큐에 현재 있는 항목의 개수를 반환합니다.",
deque,"deque는 Python의 collections 모듈에 있는 클래스로서, 덱이라고 불리는 ""양방향 큐"" 자료 구조를 구현하는 데 사용됩니다.
덱은 큐와 스택의 기능을 모두 제공하며, 양쪽 끝에서의 데이터 추가 및 삭제가 효율적으로 이루어집니다.
deque 객체는 다음과 같은 주요 메서드를 제공합니다:

append(item): 덱의 오른쪽 끝에 item을 추가합니다.
appendleft(item): 덱의 왼쪽 끝에 item을 추가합니다.
pop(): 덱의 오른쪽 끝에서 항목을 제거하고 반환합니다.
popleft(): 덱의 왼쪽 끝에서 항목을 제거하고 반환합니다.
extend(iterable): iterable에 있는 항목을 오른쪽 끝에 추가합니다.
extendleft(iterable): iterable에 있는 항목을 왼쪽 끝에 추가합니다.
rotate(n): 덱을 n만큼 회전시킵니다. 양수일 경우 오른쪽으로 회전하고, 음수일 경우 왼쪽으로 회전합니다.
clear(): 덱의 모든 항목을 제거합니다.
len(): 덱의 길이를 반환합니다.",
Counter,"Counter는 Python의 collections 모듈에 있는 클래스로서, 주어진 시퀀스(sequence)나 반복 가능한(iterable) 객체의 요소들의 개수를 셀 때 사용됩니다.
Counter는 딕셔너리(dictionary)의 서브클래스이며, 요소와 해당 요소의 개수를 키-값 쌍으로 저장합니다.
Counter 객체는 다음과 같은 주요 메서드와 속성을 제공합니다

most_common(n): 가장 빈도가 높은 상위 n개의 요소와 해당 개수를 반환합니다.
elements(): Counter 객체의 요소들을 반복 가능한 객체로 반환합니다.
update(iterable): iterable에 있는 요소들을 추가하여 카운트를 업데이트합니다.
subtract(iterable): iterable에 있는 요소들을 현재 카운터에서 뺍니다.
keys(): Counter 객체의 모든 키를 반환합니다.
values(): Counter 객체의 모든 값을 반환합니다.
items(): Counter 객체의 모든 키-값 쌍을 반환합니다.
clear(): Counter 객체의 모든 요소를 제거합니다.
get(key): 지정한 key에 해당하는 카운트 값을 반환합니다.",
defaultdict,"defaultdict는 Python의 collections 모듈에 있는 클래스로서, 딕셔너리(dictionary)의 서브클래스입니다.
기본적으로 defaultdict는 존재하지 않는 키에 대해 자동으로 기본 값을 제공하는 기능을 제공합니다.
defaultdict는 특히 딕셔너리에서 키가 존재하지 않을 경우 예외 처리를 간편하게 해주는데 사용됩니다.
예를 들어, 딕셔너리에서 키에 해당하는 값을 가져올 때, 키가 존재하지 않으면 기본 값을 제공하도록 설정할 수 있습니다.",
OrderedDict,"OrderedDict는 Python의 collections 모듈에 있는 클래스로서, 딕셔너리(dictionary)의 서브클래스입니다.
OrderedDict는 키-값 쌍의 순서를 기억하는 딕셔너리입니다.
딕셔너리와 마찬가지로 고유한 키(key)를 사용하여 값(value)에 접근할 수 있습니다.
OrderedDict는 키-값 쌍의 순서를 중요하게 여기는 경우에 유용합니다.
예를 들어, 딕셔너리에 추가된 순서를 유지하면서 데이터를 처리하거나, 딕셔너리를 정렬할 때 원래 순서를 유지하기 위해 OrderedDict를 사용할 수 있습니다.",
itertools,"itertools는 Python의 내장 모듈로서, 반복 가능한(iterable) 객체를 다루는데 사용되는 유용한 함수들을 제공합니다.
itertools 모듈은 반복자(iterator)를 생성하고 조작하는 기능을 포함하며, 반복 가능한 객체를 처리하고 조합하는 데에 유용합니다.
아래는 itertolls의 주요 함수들입니다.

1. count: 무한한 숫자 시퀀스를 생성하는 반복자를 반환합니다. 시작 값과 증가 값(기본값은 1)을 지정할 수 있습니다.
2. cycle: 반복 가능한 객체의 요소들을 무한히 반복하는 반복자를 반환합니다.
3. repeat: 지정된 값 또는 객체를 무한히 반복하는 반복자를 반환합니다. 횟수를 제한하여 반복을 제어할 수도 있습니다.
4. chain: 여러 개의 반복 가능한 객체를 하나의 시퀀스로 연결하는 반복자를 반환합니다.
5. islice: 반복 가능한 객체의 특정 범위의 요소를 선택하는 반복자를 반환합니다. 슬라이싱과 유사한 방식으로 요소를 선택할 수 있습니다.
6. product: 여러 개의 반복 가능한 객체의 카르테시안 곱을 생성하는 반복자를 반환합니다.
7. combinations 및 permutations: 반복 가능한 객체에서 조합과 순열을 생성하는 반복자를 반환합니다.",
groupby,"groupby()는 itertools 모듈에 속하는 함수로, 이터러블 객체에서 연속된 동일한 값들을 기준으로 그룹을 생성하는 기능을 제공합니다.
주로 데이터 처리나 분석 작업에서 사용되며, 특히 데이터의 그룹화와 집계에 유용하게 활용됩니다.
groupby()함수는 다음과 같이 사용됩니다.
itertools.groupby(iterable, key=None)","from itertools import groupby

numbers = [1, 1, 2, 2, 3, 3, 4, 5, 5]
result = groupby(numbers)

for key, group in result:
    print(key, list(group))

결과값:
1 [1, 1]
2 [2, 2]
3 [3, 3]
4 [4]
5 [5, 5]"
count,"count는 Python의 내장 함수로, 시퀀스(sequence)에서 특정 요소의 개수를 세는 데 사용됩니다.
주어진 요소가 시퀀스에 몇 번 등장하는지를 반환합니다.","string = ""Hello, World!""
count = string.count(""l"")
print(count)

결과값:
3"
cycle,"cycle은 Python의 itertools 모듈에 있는 함수로, 반복 가능한 객체의 요소들을 무한히 반복하는 이터레이터를 생성합니다.","import itertools

colors = ['red', 'green', 'blue']
color_cycle = itertools.cycle(colors)

for _ in range(5):
    print(next(color_cycle))

결과값:
red
green
blue
red
green
"
repeat,"repeat는 Python의 itertools 모듈에 있는 함수로, 지정된 값을 반복적으로 생성하는 이터레이터를 생성합니다.
repeat 함수는 반복적으로 동일한 값을 사용해야 하는 상황에서 유용합니다.
예를 들어, 동일한 값으로 구성된 리스트를 생성하거나, 동일한 값을 계속해서 처리해야 할 때 사용할 수 있습니다.","import itertools

repeat_iterator = itertools.repeat(5, times=3)

for value in repeat_iterator:
    print(value)

결과값:
5
5
5"
chain,"chain은 Python의 itertools 모듈에 있는 함수로, 여러 개의 반복 가능한 객체를 연결하여 하나의 이터레이터로 만들어줍니다.
chain 함수는 여러 개의 리스트, 튜플, 집합 등의 객체를 하나의 이터레이터로 연결할 때 유용합니다.
연결된 이터레이터는 연결된 객체들의 요소들을 순차적으로 순회할 수 있습니다.","import itertools

list1 = [1, 2]
tuple1 = ('a', 'b')
set1 = {4, 5}

chain_iterator = itertools.chain(list1, tuple1, set1)

for value in chain_iterator:
    print(value)

결과값:
1
2
a
b
4
5"
islice,"islice는 Python의 itertools 모듈에 있는 함수로, 반복 가능한 객체에서 특정 범위의 요소들을 선택하여 이터레이터로 반환합니다.
islice 함수를 사용하여 반복 가능한 객체에서 특정 범위의 요소를 선택할 수 있습니다.
이는 리스트, 문자열, 튜플 등의 객체에서 슬라이싱과 유사한 기능을 제공합니다.","import itertools

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

islice_iterator = itertools.islice(numbers, 2, 8, 2)

for value in islice_iterator:
    print(value)

결과값:
3
5
7"
product,"product는 Python의 itertools 모듈에 있는 함수로, 여러 개의 반복 가능한 객체의 모든 가능한 조합을 생성하는 이터레이터를 반환합니다.
product 함수를 사용하여 반복 가능한 객체들의 모든 조합을 생성할 수 있습니다.
이는 리스트, 튜플, 문자열 등의 객체에서 가능한 조합을 생성할 때 유용합니다.","import itertools

colors = ['red', 'blue']
sizes = ['S', 'L']

product_iterator = itertools.product(colors, sizes)

for item in product_iterator:
    print(item)

결과값:
('red', 'S')
('red', 'L')
('blue', 'S')
('blue', 'L')"
combinations,"combinations는 Python의 itertools 모듈에 있는 함수로, 반복 가능한 객체에서 지정된 길이의 조합을 생성하는 이터레이터를 반환합니다.
combinations 함수를 사용하여 반복 가능한 객체에서 지정된 길이의 조합을 생성할 수 있습니다.
이는 리스트, 튜플, 문자열 등의 객체에서 가능한 조합을 생성할 때 유용합니다.","import itertools

colors = ['red', 'blue', 'green']
combinations_iterator = itertools.combinations(colors, 2)

for combination in combinations_iterator:
    print(combination)

결과값:
('red', 'blue')
('red', 'green')
('blue', 'green')"
permutations,"permutations은 Python의 itertools 모듈에 있는 함수로, 반복 가능한 객체에서 지정된 길이의 순열을 생성하는 이터레이터를 반환합니다.
permutations 함수를 사용하여 반복 가능한 객체에서 지정된 길이의 순열을 생성할 수 있습니다.
이는 리스트, 튜플, 문자열 등의 객체에서 가능한 순열을 생성할 때 유용합니다.","import itertools

colors = ['red', 'blue', 'green']
permutations_iterator = itertools.permutations(colors, 2)

for permutation in permutations_iterator:
    print(permutation)

결과값:
('red', 'blue')
('red', 'green')
('blue', 'red')
('blue', 'green')
('green', 'red')
('green', 'blue')"
pandas,"pandas는 Python에서 데이터 분석과 조작을 위한 강력한 라이브러리입니다.
pandas는 고수준의 데이터 구조와 데이터 분석 도구를 제공하여 데이터 처리 작업을 간단하고 효율적으로 수행할 수 있도록 도와줍니다.
pandas의 주요 데이터 구조는 시리즈(Series)와 데이터프레임(DataFrame)입니다.
시리즈는 1차원 데이터 배열로, 인덱스와 값으로 구성됩니다.
데이터프레임은 2차원 테이블 형태의 데이터 구조로, 여러개의 시리즈가 열로 구성되어 있습니다.","import pandas as pd
df = pd.DataFrame()"
apply,"apply()는 pandas DataFrame 객체에서 사용되는 메서드로, 주어진 함수를 행이나 열에 적용하여 결과를 반환하는 기능을 제공합니다.
apply() 메서드는 데이터프레임의 각 행 또는 열에 함수를 적용하고, 결과를 새로운 시리즈(Series)나 데이터프레임(DataFrame)으로 반환합니다.
apply() 메서드의 일반적인 구문은 다음과 같습니다:

DataFrame.apply(func, axis=0)

apply() 메서드를 사용하면 사용자 정의 함수를 적용하여 데이터프레임의 열 또는 행을 처리할 수 있습니다.
이를 통해 복잡한 데이터 변환 또는 계산 작업을 수행할 수 있습니다.
","column_means = df.apply(lambda x: x.mean(), axis=0)"
describe,"describe()는 pandas DataFrame 또는 Series 객체에 대한 간단한 통계적 요약을 제공하는 메서드입니다.
주어진 데이터의 개수, 평균, 표준편차, 최소값, 백분위수 및 최대값 등을 계산하여 반환합니다.
describe() 메서드를 호출하면 다음과 같은 통계적 요약 정보를 얻을 수 있습니다:

1. Count (개수): 데이터의 총 개수를 반환합니다.
2. Mean (평균): 데이터의 평균값을 반환합니다.
3. Standard Deviation (표준편차): 데이터의 표준편차를 반환합니다.
4. Minimum (최소값): 데이터의 최솟값을 반환합니다.
5. 25th Percentile (1사분위수): 데이터의 25% 지점에 위치한 값입니다.
6. 50th Percentile (2사분위수 또는 중앙값): 데이터의 중앙에 위치한 값입니다.
7. 75th Percentile (3사분위수): 데이터의 75% 지점에 위치한 값입니다.
8. Maximum (최대값): 데이터의 최댓값을 반환합니다.",
matplotlib,"matplotlib는 Python에서 데이터 시각화를 위한 라이브러리로, 다양한 그래프와 차트를 생성할 수 있는 강력한 기능을 제공합니다.
데이터의 시각적인 표현을 통해 패턴, 경향성, 관계 등을 시각적으로 이해할 수 있게 해주며, 데이터 분석 및 통계 작업에서 널리 사용됩니다.",import matplotlib.pyplot as plt
seaborn,"seaborn은 Python의 데이터 시각화 라이브러리로, matplotlib을 기반으로 한다는 점에서 많은 유사점을 가지고 있습니다.
그러나 seaborn은 matplotlib의 기능을 보완하고 확장하여 보다 간편하고 시각적으로 매력적인 그래프를 생성하는 데 중점을 둔 라이브러리입니다.",import seaborn as sns
sys,"sys는 Python의 내장 모듈로, 시스템과 관련된 기능에 접근할 수 있게 해주는 모듈입니다.
sys 모듈은 Python 인터프리터와 인터프리터의 동작 환경에 대한 정보를 제공하고, Python 스크립트의 실행 제어, 명령행 인수 처리, 입출력 관리 등의 기능을 제공합니다.
sys 모듈의 주요 기능과 속성은 다음과 같습니다:

1. sys.argv: 명령행 인수(command-line arguments)를 저장한 리스트입니다. 프로그램 실행 시 전달된 인수들을 접근할 수 있습니다.
2. sys.exit(): 프로그램을 강제로 종료합니다.
3. sys.path: 모듈을 검색할 경로를 저장한 리스트입니다. Python 모듈을 찾는 경로를 지정하거나 확인할 수 있습니다.
4. sys.modules: 현재 로드된 모든 모듈의 딕셔너리입니다. 모듈의 이름과 해당 모듈 객체를 매핑한 정보를 포함합니다.
5. sys.stdin, sys.stdout, sys.stderr: 표준 입력(stdin), 표준 출력(stdout), 표준 오류(stderr)에 대한 파일 객체입니다. 입출력을 다룰 때 사용됩니다.
6. sys.platform: 현재 Python 인터프리터가 실행 중인 플랫폼을 나타내는 문자열입니다.",
bisect,"bisect는 Python의 내장 모듈인 bisect 모듈을 의미합니다.
bisect 모듈은 정렬된 시퀀스에서 요소를 삽입할 위치를 찾거나, 정렬된 시퀀스에서 특정 값이 위치해야 할 인덱스를 찾는 기능을 제공합니다.
이를 통해 효율적인 삽입 및 탐색 작업을 수행할 수 있습니다.
아래는 bisect 모듈에서 제공하는 주요 함수들 입니다.

1. bisect_left(a, x, lo=0, hi=len(a)): 정렬된 시퀀스 a에 대해, 값 x가 삽입되어야 할 왼쪽 위치(인덱스)를 반환합니다. 시퀀스에 중복된 값이 있을 경우, 왼쪽에 위치하는 인덱스를 반환합니다.
2. bisect_right(a, x, lo=0, hi=len(a)): 정렬된 시퀀스 a에 대해, 값 x가 삽입되어야 할 오른쪽 위치(인덱스)를 반환합니다. 시퀀스에 중복된 값이 있을 경우, 오른쪽에 위치하는 인덱스를 반환합니다.
3. bisect(a, x, lo=0, hi=len(a)): bisect_right() 함수와 동일한 기능을 수행합니다. 오른쪽에 위치하는 인덱스를 반환합니다.
4. insort_left(a, x, lo=0, hi=len(a)): 정렬된 시퀀스 a에 값 x를 삽입합니다. 삽입 후에도 시퀀스가 정렬 상태를 유지합니다. 중복된 값이 있을 경우, 왼쪽에 삽입됩니다.
5. insort_right(a, x, lo=0, hi=len(a)): 정렬된 시퀀스 a에 값 x를 삽입합니다. 삽입 후에도 시퀀스가 정렬 상태를 유지합니다. 중복된 값이 있을 경우, 오른쪽에 삽입됩니다.
",
heapq,"heapq는 Python의 내장 모듈로서, 최소 힙(min-heap) 기능을 제공합니다. 힙은 데이터 구조 중 하나로, 가장 작은 값을 상위에 위치시켜 빠르게 접근할 수 있는 자료구조입니다.
heapq 모듈은 리스트를 힙으로 관리하고, 최소값을 빠르게 찾고 추가/제거할 수 있는 함수들을 제공합니다.
아래는 몇 가지 heapq 모듈에서 제공하는 주요 함수입니다.

1. heapify: 주어진 리스트를 힙으로 변환합니다. 리스트의 요소들이 힙의 규칙에 따라 재정렬됩니다.
2. heappush: 힙에 요소를 추가합니다. 요소는 힙의 규칙에 따라 적절한 위치에 삽입됩니다.
3. heappop: 힙에서 최소값을 제거하고 반환합니다. 힙의 구조를 유지하기 위해 다른 요소들을 재정렬합니다.
4. heapreplace: 힙에서 최소값을 제거하고 새로운 요소를 삽입합니다. heappop과 heappush를 한 번에 수행하는 것과 유사하지만, 최소값을 반환하지 않고 바로 새로운 요소를 삽입합니다.
5. heappushpop: 새로운 요소를 힙에 삽입하고 동시에 최소값을 제거합니다. heappush와 heappop을 한 번에 수행하는 것과 유사하지만, 최소값을 반환하지 않고 새로운 요소를 삽입합니다.",
and,'and'는 Python에서 사용되는 논리 연산자입니다. '그리고'라는 의미를 가지며 두 개의 조건이 참일 때 전체 표현식이 참이 됩니다.,"if 1 == 1 and 3 > 1:
    print(True)

결과값:
True
"
or,'or'은 Python에서 사용되는 논리 연산자입니다. '또는'라는 의미를 가지며 두 개의 조건 중 하나 이상이 참일 때 전체 표현식이 참이 됩니다.,"
if 1 == 0 or 3 > 1:
    print(True)

결과값:
True
"
operator,"Python에서 숫자간의 연산이 이루어질 때 사용되는 연산자입니다.
다음은 Python에서 자주 사용되는 연산자 입니다.

1. + (덧셈): 두 개의 숫자를 더합니다. 또는 두 개의 문자열을 연결합니다.
2. - (뺄셈): 첫 번째 숫자에서 두 번째 숫자를 뺍니다.
3. * (곱셈): 두 개의 숫자를 곱합니다. 또는 문자열을 반복합니다.
4. / (나눗셈): 첫 번째 숫자를 두 번째 숫자로 나눕니다. 결과는 부동소수점 숫자입니다.
5. % (나머지): 첫 번째 숫자를 두 번째 숫자로 나눈 후 나머지를 반환합니다.
6. ** (지수 연산): 첫 번째 숫자를 두 번째 숫자의 지수로 계산합니다. 즉, 첫 번째 숫자를 두 번째 숫자만큼 곱합니다.
7. // (정수 나눗셈): 첫 번째 숫자를 두 번째 숫자로 나눈 후 소수점 이하를 버리고 정수 부분만 반환합니다.
8. = (할당): 오른쪽 피연산자의 값을 왼쪽 피연산자에 할당합니다.
9. == (등호): 두 개의 값이 서로 같은지 비교합니다. 같으면 True를, 다르면 False를 반환합니다.
10. != (부등호): 두 개의 값이 서로 다른지 비교합니다. 다르면 True를, 같으면 False를 반환합니다.
11. > (크다): 첫 번째 값이 두 번째 값보다 큰지 비교합니다. 크면 True를, 작거나 같으면 False를 반환합니다.
12. < (작다): 첫 번째 값이 두 번째 값보다 작은지 비교합니다. 작으면 True를, 크거나 같으면 False를 반환합니다.
13. >= (크거나 같다): 첫 번째 값이 두 번째 값보다 크거나 같은지 비교합니다. 크거나 같으면 True를, 작으면 False를 반환합니다.
14. <= (작거나 같다): 첫 번째 값이 두 번째 값보다 작거나 같은지 비교합니다. 작거나 같으면 True를, 크면 False를 반환합니다.","print(2 + 2)
print(2 - 2)
print(2 * 2)
print(2 / 2)
print(3 % 2)
print(3 ** 2)
print(3 // 2)
number = 10
print(number)
print(1 == 1)
print(1 != 1)
print(2 > 1)
print(2 < 1)
print((1+1) >= 2)
print((1+1) <= 2)

결과값:
4
0
4
1.0
1
9
1
10
True
False
True
False
True
True"
strip,"strip()은 문자열에서 양쪽 끝에 있는 공백이나 특정 문자를 제거하는 Python의 문자열 메서드입니다.
strip() 메서드는 다음과 같은 형식으로 사용됩니다

string.strip([characters])

string: 공백이나 특정 문자를 제거할 대상 문자열입니다.
characters (옵션): 제거할 문자 집합입니다. 기본값은 None으로 설정되어 있으며, 이 경우 공백을 제거합니다.
만약 characters 인자가 제공되면, 문자열의 양쪽 끝에서 해당 문자들을 제거합니다.

필요에 따라 좌우 선택한 부분만 제거할 수 있습니다.
lstrip(), rstrip()을 이용하여 각각 left, right에 있는 특정 문자를 제거할 수 있습니다.","string = "">>Hello, World!<<""
stripped_string = string.strip(""><"")
print(stripped_string)

결과값:
""Hello, World!"""
add,일반적으로 add() 메서드는 컬렉션 또는 집합에 요소를 추가하는데 사용됩니다.,"my_set = {1, 2, 3}
my_set.add(4)
print(my_set)

결과값:
{1, 2, 3, 4}"
sum,"sum()은 Python의 내장 함수로, 숫자의 합을 계산하는 데 사용됩니다. 주어진 숫자 시퀀스의 모든 요소를 더해서 총합을 반환합니다.
sum() 함수는 다음과 같은 형식으로 사용됩니다

sum(iterable, start=0)

iterable: 숫자 시퀀스(리스트, 튜플 등)입니다. 요소들은 숫자형이어야 합니다.
start (옵션): 총합을 계산하기 전에 시작 값으로 사용되는 숫자입니다. 기본값은 0입니다.","numbers = [1, 2, 3, 4, 5]
total = sum(numbers, start=10)
print(total)

결과값: 25"
datetime,"datetime은 Python의 내장 모듈로, 날짜와 시간을 다루는 클래스와 함수를 제공합니다.
이 모듈을 사용하여 날짜, 시간, 날짜 및 시간 간의 연산을 수행하고, 형식화된 문자열로의 변환 등 다양한 작업을 할 수 있습니다.
datetime 모듈에서 주로 사용되는 클래스와 함수는 다음과 같습니다

1. datetime : 날짜와 시간을 모두 포함하는 객체를 생성할 수 있습니다. 날짜와 시간의 연산, 형식화, 추출 등을 수행할 수 있습니다.
2. date : 날짜만을 포함하는 객체를 생성할 수 있습니다. 날짜 간의 연산, 형식화, 추출 등을 수행할 수 있습니다.
3. time : 시간만을 포함하는 객체를 생성할 수 있습니다. 시간 간의 연산, 형식화, 추출 등을 수행할 수 있습니다.
4. timedelta : 시간 간격을 나타내는 객체를 생성할 수 있습니다. 날짜와 시간 간의 차이를 계산하거나 시간에 대한 연산을 수행할 때 사용됩니다.","from datetime import datetime

now = datetime.now()
print(now)

결과값: 2023-06-24 14:50:07.123456"
pytz,"pytz는 Python에서 사용되는 시간대 관련 작업을 지원하는 외부 패키지입니다.
Python의 기본 모듈인 datetime은 시간과 날짜를 다루는 강력한 도구지만, 시간대와 관련된 작업을 처리하기 위해서는 pytz와 같은 외부 패키지를 사용해야 합니다.
pytz는 세계 여러 지역의 시간대 정보를 제공하고, 시간대 변환과 관련된 기능을 제공합니다.
패키지 이용을 위해서 pip를 이용한 설치 과정이 필요합니다.","from datetime import datetime
import pytz

# 현재 시간
now = datetime.now()

# 현재 시간을 뉴욕 시간대로 변환
ny_tz = pytz.timezone('America/New_York')
ny_time = now.astimezone(ny_tz)
print(ny_time)

결과값:
2023-06-26 02:12:15.389499-04:00"
isalnum,"isalnum()은 문자열의 모든 문자가 알파벳 문자(영문자) 또는 숫자인지 확인하는 Python의 문자열 메서드입니다.
문자열에 포함된 모든 문자가 알파벳 문자(영문자 a-z 및 A-Z) 또는 숫자(0-9)인 경우에만 True를 반환하고, 그렇지 않으면 False를 반환합니다.
공백, 특수 문자, 기호 등이 포함되어 있으면 False를 반환합니다.","string1 = ""Hello123""
string2 = ""Hello, World!""

print(string1.isalnum())
print(string2.isalnum())

출력: 
True # 알파벳 문자와 숫자로만 구성됨
False # 쉼표와 공백이 포함되어 있음"
swapcase,"swapcase()는 문자열의 대소문자를 상호 전환하는 Python의 문자열 메서드입니다.
swapcase() 메서드는 문자열 내의 모든 대문자를 소문자로, 소문자를 대문자로 전환하여 새로운 문자열을 반환합니다.
즉, 대소문자를 서로 뒤바꾼 문자열을 생성합니다.","string = ""Hello, World!""

swapped_string = string.swapcase()
print(swapped_string)

결과값:
hELLO, wORLD!"
upper,"upper()는 문자열을 모두 대문자로 변환하는 Python의 문자열 메서드입니다.
upper() 메서드는 문자열 내의 모든 소문자를 대문자로 변환하여 새로운 문자열을 반환합니다.
원본 문자열은 변경되지 않고 대문자로 변환된 새로운 문자열이 반환됩니다.","string = ""Hello, World!""
uppercase_string = string.upper()
print(uppercase_string)

결과값:
HELLO, WORLD!"
lower,"lower()는 문자열을 모두 소문자로 변환하는 Python의 문자열 메서드입니다.
lower() 메서드는 문자열 내의 모든 대문자를 소문자로 변환하여 새로운 문자열을 반환합니다.
원본 문자열은 변경되지 않고 소문자로 변환된 새로운 문자열이 반환됩니다.","string = ""Hello, World!""

lowercase_string = string.lower()
print(lowercase_string)

결과값:
hello, world!"
math,"math는 Python의 내장 모듈 중 하나로, 수학적인 연산을 수행하는 함수와 상수를 제공합니다.
아래는 math 모듈에서 주로 사용되는 몇 가지 함수와 상수입니다.

수학 함수:
    math.sqrt(x): 숫자 x의 제곱근을 반환합니다.
    math.pow(x, y): 숫자 x의 y 제곱을 반환합니다.
    math.sin(x), math.cos(x), math.tan(x): 숫자 x의 사인, 코사인, 탄젠트 값을 반환합니다.
    math.radians(x): 각도를 라디안으로 변환합니다.
    math.degrees(x): 라디안을 각도로 변환합니다.
    math.log(x), math.log10(x): 숫자 x의 자연 로그, 상용 로그 값을 반환합니다.
    math.exp(x): 지수 함수 e^x 값을 반환합니다.
    math.factorial(x): 숫자 x의 팩토리얼 값을 반환합니다.
상수:
    math.pi: 원주율(π)의 근사치인 상수입니다.
    math.e: 자연 로그의 밑수인 오일러 수(e)의 근사치인 상수입니다.

이 외에 다양한 수학적인 함수와 상수를 제공합니다. 자세한 내용은 공식 Python 문서를 참고하세요","
"
remove,"remove()는 Python 리스트(list)에서 특정 요소를 제거하는 내장 함수입니다.
remove() 함수는 리스트에서 첫 번째로 일치하는 값을 찾아 제거합니다.
리스트에서 해당 값이 여러 번 등장하더라도 첫 번째로 일치하는 값만 제거됩니다.

만약 리스트에 제거하려는 값이 존재하지 않는다면 ValueError 예외가 발생합니다.
따라서 remove() 함수를 사용하기 전에 제거하려는 값이 리스트에 있는지 확인하는 것이 좋습니다.
","my_list = [1, 2, 3, 4, 5]
my_list.remove(3)
print(my_list)

결과값:
[1, 2, 4, 5]"
abs,abs() 함수는 주어진 숫자의 절댓값을 반환하는 내장 함수입니다.,"num1 = -5
num2 = 3.14
abs_num1 = abs(num1)
abs_num2 = abs(num2)

print(abs_num1)
print(abs_num2)

결과값:
5
3.14"
drop,"drop()은 Pandas 라이브러리에서 제공하는 함수로, DataFrame이나 Series에서 특정 행 또는 열을 제거하는 역할을 합니다.","# row 제거
df.drop(0)

# column 제거
df.drop(columns='Column_name', axis=1)"
typing,"typing은 Python 3.5부터 도입된 내장 모듈로, 타입 힌트(type hint)를 지원하기 위한 도구들을 제공합니다.
다음은 typing의 요한 클래스와 함수에 대한 설명입니다.

1. Any: 모든 타입을 나타내는 특수한 타입으로, 동적 타입을 사용하는 경우 유용합니다.
2. Union: 여러 개의 타입 중 하나를 나타내기 위해 사용되는 클래스입니다. Union[int, float]와 같이 사용하여 정수나 부동소수점 타입 중 하나를 표현할 수 있습니다.
3. List, Tuple, Dict, Set: 각각 리스트, 튜플, 딕셔너리, 집합 타입을 나타내는 클래스입니다.
4. Callable: 함수 객체를 나타내는 타입 힌트로, 함수가 받는 매개변수와 반환 타입을 지정할 수 있습니다.
5. Optional: 특정 타입 또는 None을 나타내는 타입 힌트입니다. Optional[int]는 정수나 None을 나타냅니다.","from typing import List, Tuple

# 함수의 변수가 정수(int)로 구성된 리스트 타입으로 지정됨.
def calculate_sum(numbers: List[int]) -> int:
    return sum(numbers)"
mypy,"mypy는 Python 코드의 정적 타입 검사를 수행하기 위한 도구입니다.
Python은 동적 타입 언어로써 코드 작성 시에 변수의 타입을 명시적으로 선언하지 않아도 되는 특징이 있습니다.
이는 유연하고 간결한 코드 작성을 가능하게 해줍니다.
그러나 때로는 코드의 복잡성이 증가하고 유지 보수가 어려워질 수 있습니다.
mypy는 이러한 상황에서 코드의 타입 오류를 사전에 검출하여 개발자가 실수를 방지하고 코드의 안정성을 높일 수 있도록 도와줍니다.",
type hint,"Type hint는 Python 3.5부터 도입된 기능으로 변수, 함수, 메서드 등의 선언부에 해당 변수 또는 반환값의 예상되는 자료형을 명시하는 주석을 추가하는 것을 말합니다.
이를 통해 코드의 가독성을 높이고, 개발자와 도구에게 타입 정보를 제공하여 정적 타입 검사와 자동 완성 등의 기능을 지원합니다.","def func(a: int) -> int : #type hint
    b: int = 1
    return a+b"
numpy,"NumPy는 Python에서 과학적 계산과 데이터 분석을 위한 핵심 라이브러리입니다.
NumPy는 과학적 계산, 통계, 머신러닝, 이미지 처리 등 다양한 분야에서 널리 사용되는 라이브러리입니다.
NumPy는 다차원 배열 객체와 이를 다루기 위한 다양한 함수와 도구들을 제공하여 연산등을 효율적으로 수행할 수 있게 해줍니다.
다음은 NumPy의 주요한 기능입니다.

1. 다차원 배열(ndarray): NumPy의 핵심 데이터 구조로, 고성능의 배열 계산을 지원합니다. 다차원 배열은 동일한 타입의 원소를 가지며, 배열의 차원과 크기를 가지고 있습니다.
2. 브로드캐스팅(Broadcasting): 다른 크기의 배열 간에도 산술 연산을 수행할 수 있게 해주는 기능입니다. 브로드캐스팅은 배열의 차원을 임의로 확장하여 연산이 가능하도록 합니다.
3. 벡터화 연산(Vectorized operations): NumPy는 배열에 대한 연산을 빠르게 수행할 수 있는 벡터화 연산을 지원합니다. 벡터화 연산은 반복문 없이 배열의 모든 원소에 대해 한 번에 연산을 수행하는 기능입니다.
4. 선형 대수 연산: NumPy는 다양한 선형 대수 연산을 지원합니다. 행렬의 곱셈, 역행렬, 특잇값 분해 등의 연산을 수행할 수 있습니다.
5. 난수 생성: 다양한 종류의 난수를 생성할 수 있는 기능을 제공합니다. 난수 생성기를 사용하여 난수 배열을 생성하거나, 통계적인 분포를 따르는 난수를 생성할 수 있습니다.
6. 데이터 입출력: NumPy는 배열 데이터를 파일로 저장하고 읽어오는 기능을 제공합니다. 다양한 파일 형식을 지원하며, 배열을 효율적으로 디스크에 저장하고 불러올 수 있습니다.",
global,"global은 Python에서 변수의 범위(scope)를 지정하는 키워드입니다.
일반적으로 함수 내에서 변수를 정의하면 해당 변수는 함수 내에서만 유효한 지역 변수(local variable)로 취급됩니다.
하지만 global 키워드를 사용하면 함수 내에서 전역 변수(global variable)를 참조하거나 수정할 수 있습니다.

global 키워드를 사용할 때 주의해야 할 점은 변수의 범위를 전역으로 확장하는 것이기 때문에 변수명 충돌에 주의해야 합니다.
여러 함수에서 동일한 이름의 전역 변수를 사용하면 예상치 못한 결과를 초래할 수 있으므로 변수명을 신중하게 선택해야 합니다.","x = 10  # 전역 변수

def foo():
    global x  # x를 전역 변수로 선언
    x = 20   # 전역 변수 x의 값을 변경
foo()
print(x)

결과값:
20"
local variable,"로컬 변수(Local variable)는 프로그램에서 특정한 함수, 메서드, 루프 또는 코드 블록 내에서 선언되고 사용되는 변수입니다.
로컬 변수는 해당 코드 블록 내에서만 유효하며, 다른 코드 블록에서는 접근할 수 없습니다.","x = 10  # 전역 변수

def foo():
    number = x*2
    return number
print(foo())
print(x)"
global variable,"전역 변수(Global variable)는 프로그램 어디에서나 접근할 수 있는 변수로, 전역 스코프(Global scope)에서 선언되는 변수를 말합니다.
전역 변수는 프로그램의 어느 곳에서든 참조하고 수정할 수 있으며, 여러 함수 또는 모듈에서 공유하여 사용할 수 있습니다.","def foo():
    x = 20
    return x   # 지역 변수 x의 값을 설정
print(foo())
print(x)

결과값:
20
NameError # x가 함수 밖에선 선언되지 않아서 Error 발생."
urllib,"urllib은 Python의 표준 라이브러리 중 하나로, URL과 관련된 작업을 수행하는데 사용됩니다.
urllib은 웹 스크래핑, 웹 API 호출, 웹 리소스 다운로드 등 다양한 웹 관련 작업을 수행할 수 있도록 도와줍니다.
다음은 urllib에서 사용되는 모듈입니다.

1. urllib.request: HTTP 요청을 보내고 응답을 받기 위한 기능을 제공합니다. 웹 페이지를 다운로드하거나 API에 요청을 보내는 등의 작업에 사용됩니다.
2. urllib.parse: URL을 파싱하고 조작하는 기능을 제공합니다. URL의 구성 요소를 추출하거나 조작하여 새로운 URL을 생성하는 등의 작업에 사용됩니다.
3. urllib.error: urllib.request 모듈에서 발생하는 예외들을 정의하고 있습니다. HTTP 요청 중 발생할 수 있는 예외를 처리하는 데 사용됩니다.
4. urllib.robotparser: 로봇 배제 프로토콜(Robots.txt)을 해석하여 웹 사이트의 크롤링 규칙을 확인하는 기능을 제공합니다.",
setrecursionlimit,"setrecursionlimit 함수는 Python에서 재귀 호출의 최대 깊이를 설정하는 함수입니다.
재귀 호출은 함수가 자기 자신을 호출하는 것을 의미하며, 재귀 호출의 깊이는 함수가 재귀적으로 호출될 수 있는 최대 횟수를 나타냅니다.",sys.setrecursionlimit(2000) # 재귀 호출 깊이를 2000회로 설정
copy,"copy()는 Python에서 객체를 복사하는 함수입니다.
이 함수를 사용하면 원본 객체의 내용을 새로운 객체로 복사하여 독립적인 복사본을 생성할 수 있습니다.","original_list = [1, 2, 3]
copied_list = original_list.copy()
print(copied_list)

결과값:
[1, 2, 3]"
functools,"functools는 Python의 내장 모듈 중 하나로, 함수 작업을 지원하는 유틸리티 함수들을 제공합니다.
다음은 functools의 주요 기능입니다.

1. partial: 함수의 일부 인수를 고정한 새로운 함수를 생성합니다. 즉, 기존 함수에서 일부 인수를 미리 설정하여 새로운 함수를 생성하는 것입니다.
2. reduce: 시퀀스의 요소를 순서대로 결합하여 단일 값으로 줄이는 작업을 수행합니다. 주로 누적 연산에 사용됩니다.
3. wraps: 데코레이터를 작성할 때 함수의 메타데이터를 보존하기 위해 사용됩니다. 원본 함수의 속성을 데코레이트된 함수로 복사하여 함수의 원본 정보를 유지합니다.
4. lru_cache: 함수의 결과를 캐싱하여 중복 호출 시 이전 결과를 반환하는 메모이제이션 기능을 제공합니다. 함수 호출의 속도를 향상시킬 수 있습니다.
5. cmp_to_key: 비교 함수를 키 함수로 변환하여 정렬 및 순서 비교에 사용할 수 있습니다.","from functools import partial

def power(base, exponent):
    return base ** exponent

square = partial(power, exponent=2)
square(2) # 한 변의 길이가 2인 정사각형의 넓이

결과값:
4"
zfill,"zfill()은 문자열 메서드로, 주어진 길이보다 짧은 문자열을 왼쪽에 0으로 채워주는 기능을 제공합니다.
zfill() 메서드의 사용 형식은 다음과 같습니다

string.zfill(width)

여기서 string은 원하는 문자열이고, width는 최종 문자열의 길이를 나타내는 정수입니다.","number = ""42""
padded_number = number.zfill(5)
print(padded_number)

결과값:
""00042"""
re,"re는 Python의 정규 표현식(regular expression)을 처리하기 위한 내장 모듈입니다.
정규 표현식은 특정 패턴을 기술하는 문자열입니다.
re 모듈은 이러한 정규 표현식을 사용하여 문자열 검색, 매칭, 치환 등의 작업을 수행할 수 있습니다.
다음은 re 모듈에서 주로 사용되는 함수와 메서드입니다.

1. re.search(pattern, string): 주어진 문자열에서 패턴과 일치하는 첫 번째 위치를 찾습니다. re.Match 객체를 반환합니다.
2. re.match(pattern, string): 주어진 문자열의 시작부터 패턴과 일치하는지 검사합니다. re.Match 객체를 반환합니다.
3. re.findall(pattern, string): 주어진 문자열에서 패턴과 일치하는 모든 부분을 찾아 리스트로 반환합니다.
4. re.finditer(pattern, string): 주어진 문자열에서 패턴과 일치하는 모든 부분을 찾아 re.Match 객체를 생성하는 이터레이터를 반환합니다.
5. re.sub(pattern, repl, string): 주어진 문자열에서 패턴과 일치하는 부분을 다른 문자열로 치환합니다.
6. re.compile(pattern): 주어진 패턴을 컴파일하여 정규 표현식 객체를 생성합니다. 컴파일된 패턴은 나중에 재사용할 수 있습니다.","import re

print(re.sub('[0-9]', '_', 'I have 100 bananas and 200 apples'))

결과값:
I have ___ bananas and ___ apples"
replace,"replace()는 문자열 메서드로, 문자열 내의 특정 문자나 문자열을 다른 문자나 문자열로 치환하는 기능을 제공합니다.
다음과 같은 형식으로 사용이 가능합니다.
string.replace(old, new)","sentence = ""Hello, world!""
new_sentence = sentence.replace(""world"", ""Python"")
print(new_sentence)

결과값: ""Hello, Python!"""
encode,"encode()는 문자열을 특정 인코딩으로 인코딩하는 메서드입니다.
문자열을 바이트로 변환하기 위해 사용되며, 변환된 바이트는 다른 시스템이나 네트워크 간에 데이터를 전송하거나 저장하는 데 사용될 수 있습니다.","text = ""안녕하세요""
encoded_text = text.encode('utf-8')
print(encoded_text)

결과값:
b'ìëíì¸ì'
"
os,"os는 Python 내장 모듈인 os 모듈을 가리킵니다.
os 모듈은 운영체제와 상호작용하기 위한 다양한 함수와 메서드를 제공합니다.
os 모듈을 사용하면 파일 및 디렉터리 작업, 환경 변수 접근, 프로세스 관리 등 다양한 운영체제 관련 작업을 수행할 수 있습니다.",
keys,"keys()는 Python 딕셔너리(Dictionary) 객체의 메서드 중 하나입니다.
keys() 메서드는 딕셔너리에서 모든 키(key)를 반환하는 메서드입니다.","person = {'name': 'John', 'age': 30, 'city': 'New York'}
keys = person.keys()
print(keys)

결과값:
dict_keys(['name', 'age', 'city'])"
values,"values()는 Python 딕셔너리(Dictionary) 객체의 메서드 중 하나입니다.
values() 메서드는 딕셔너리에서 모든 값(value)을 반환하는 메서드입니다.","person = {'name': 'John', 'age': 30, 'city': 'New York'}
values = person.values()
print(values)

결과값:
dict_values(['John', 30, 'New York'])"
get,"get()은 Python 딕셔너리(Dictionary) 객체의 메서드 중 하나입니다.
get() 메서드는 주어진 키(key)에 대응하는 값을 반환하는 메서드입니다.","person = {'name': 'John', 'age': 30, 'city': 'New York'}
name = person.get('name')
print(name)

결과값:
'John'
"
popitem,"popitem()은 Python 딕셔너리(Dictionary) 객체의 메서드 중 하나입니다.
popitem() 메서드는 딕셔너리에서 임의의 키-값 쌍을 제거하고 반환하는 메서드입니다.","person = {'name': 'John', 'age': 30, 'city': 'New York'}
item = person.popitem()

print(item)
print(len(person))

결과값:
('city', 'New York')
2"
clear,"clear()는 Python 딕셔너리(Dictionary) 객체의 메서드 중 하나입니다.
clear() 메서드는 딕셔너리의 모든 키-값 쌍을 제거하는 메서드입니다. 딕셔너리를 빈 상태로 만듭니다.","person = {'name': 'John', 'age': 30, 'city': 'New York'}
person.clear()
print(person)

결과값: 
{}"
iterator,"iterator는 Python에서 순회 가능한 객체(iterable)의 요소에 접근하는 방법을 제공하는 객체입니다.
iterator는 iterable객체에서 iter() 함수를 통해 생성하고 next() 함수를 통해 다음 요소로 이동합니다.
더 이상 요소가 없는 경우 'StopIteration' 예외를 발생시킵니다.","my_list = [1, 2, 3, 4, 5]
my_iterator = iter(my_list)

print(next(my_iterator))
print(next(my_iterator))
print(next(my_iterator))

결과값:
1
2
3"
yield,"yield는 generator 함수를 정의하거나 사용할 때 사용됩니다.
yield는 제너레이터 함수 안에서 사용되며, 이터레이터를 생성하고 데이터를 순차적으로 반환할 수 있도록 합니다.
yield는 제너레이터 함수의 상태를 보존한 채로 값을 반환한 뒤 일시 중단하고 다시 재개할 수 있습니다.","def ex_generator():
    yield 1
    yield 2
    yield 3

gen = ex_generator()

print(next(gen))
print(next(gen))
print(next(gen))

결과값:
1
2
3"
generator,"Generator(제너레이터)는 파이썬에서 이터레이터(Iterator)를 생성하는 함수입니다.
이터레이터는 값을 한 번에 하나씩 반환하는 객체로, 순회 가능한 데이터 시퀀스를 표현할 수 있습니다.
제너레이터는 이터레이터를 생성하기 위한 특별한 형태의 함수로 작성되며, yield 키워드를 사용하여 값을 반환합니다.

제너레이터는 큰 데이터 집합을 처리하거나 순차적으로 계산이 필요한 경우, 메모리를 효율적으로 사용하고 실행 속도를 향상시킬 수 있는 강력한 도구입니다.
또한, 제너레이터는 무한한 시퀀스를 생성할 수 있으므로 필요에 따라 무한한 데이터 스트림을 다룰 수 있습니다.","def ex_generator():
    yield 1
    yield 2
    yield 3

gen = ex_generator()

print(next(gen))
print(next(gen))
print(next(gen))

결과값:
1
2
3
"
coroutine,"Coroutine(코루틴)은 동시성 프로그래밍을 위한 개념으로, 제어 흐름을 동적으로 전환하며 실행을 일시 중단하고 재개할 수 있는 함수입니다.
Coroutine은 제너레이터와 유사한 동작을 하지만, 값을 소비할 뿐 아니라 생산할 수 있습니다.
코루틴은 일반적으로 async, await 키워드와 함께 사용됩니다.
Coroutine은 단일 스레드에서 여러 개의 동시 작업을 수행하고, 비동기 코드를 더 간결하고 효율적으로 작성할 수 있는 방법을 제공합니다.","import asyncio

async def ex_coroutine_1():
    print('ex_coroutine_1 start')
    await asyncio.sleep(2)
    print('ex_coroutine_1 end')

async def ex_coroutine_2():
    print('ex_coroutine_2 start')
    await asyncio.sleep(2)
    print('ex_coroutine_2 end')

async def main():
    print('main start')
    await asyncio.gather(ex_coroutine_1(), ex_coroutine_2())
    print('main end')

await main()

결과값:
main start
ex_coroutine_1 start
ex_coroutine_2 start
ex_coroutine_1 end
ex_coroutine_2 end
main end
"
async,"async은 비동기 함수를 선언할 때 사용되는 키워드입니다.
async 키워드를 사용하여 정의된 함수는 비동기적으로 동작하고, 'await' 키워드를 사용하여 다른 비동기 작업의 완료를 기다릴 수 있습니다.","import asyncio

async def ex_coroutine_1():
    print('ex_coroutine_1 start')
    await asyncio.sleep(2)
    print('ex_coroutine_1 end')"
await,"await는 비동기 함수 내에서 사용되며, 비동기 작업의 완료를 기다리는 역할을 합니다.","import asyncio

async def main():
    print('main start')
    await asyncio.gather(ex_coroutine()) # ex_coroutine()의 완료를 기다림.
    print('main end')"
AssertionError,"AssertionError는 assert 문이 실패할 때 발생하는 에러입니다.
assert문은 주어진 조건이 거짓인 경우 에러를 일으키는 함수이며, if 조건문과 같이 동작합니다.
assert 함수는 주로 프로그램 점검을 할 때 이용됩니다.","x = 999
assert x != 999

결과값:
      1 x = 999
----> 2 assert x != 999
AssertionError:    "
AttributeError,"AttributeError는 대상이 지원하지 않는 함수를 사용하려 할 때 발생하는 에러입니다.
예를 들어, 숫자에 문자열을 대상으로 사용되는 함수를 사용할 경우 등의 문제에서 발생합니다.","x = 9989
x.split(8)

결과값:
      1 x = 9989
----> 2 x.split(8)
AttributeError: 'int' object has no attribute 'split"
EOFError,"EOFError는 'End of file Error'의 약자로, 파일 또는 입력 스트림의 끝에 도달했을 때 발생하는 오류입니다.
이 오류는 일반적으로 입력 함수(input)나 읽기 작업(open)을 수행할 때 발생합니다.
오류가 발생하는 상황의 예시는 다음과 같습니다.

1. input()함수를 사용하여 사용자로부터 입력을 받을 때, 인터프리터 오류 혹은 사용자의 입력 강제 종료가 일어나는 경우 EOFError가 발생합니다.
2. 파일을 읽을 때, 파일의 끝에서 read() 혹은 readline() 함수가 호출될 때 EOFError가 발생합니다.","inputfile = open('./file.txt', 'r') # 4줄로 구성된 txt file

while True:
    line = inputfile.readline()
    print(line)

    if not line: # text가 없을 시 에러 발생
        raise EOFError(""End of file reached"")

결과값:
first
second
third
end

      7 if not line:
----> 8     raise EOFError(""End of file reached"")

EOFError: End of file reached"
FloatingPointError,"FloatingPointError는 부동 소수점 연산에서 발생하는 예외입니다.
주로 0(=0.0)으로 나누는 연산이나 대수적인 연산과정 중 실수 범위에 해당하지 않는 결과값이 나올 때 발생합니다.
다만, 0으로 나누는 경우는 ZeroDivisionError, 실수 범위가 아닌 경우는 ValueError와 같이 다른 예외가 발생합니다.
FloatingPointError는 명시적으로 설정하지 않으면 발생하지 않습니다.","import numpy as np

with np.errstate(invalid='raise'):
    np.sqrt(-1)

      3 with np.errstate(invalid='raise'):
----> 4     np.sqrt(-1)

FloatingPointError: invalid value encountered in sqrt"
GeneratorExit,"GeneratorExit는 제너레이터 또는 코루틴이 종료될 때 발생하며, 일반적으로 Generator객체의 close() 매서드를 호출하거나 Generator 루프가 종료될 때 발생합니다.
GeneratorExit는 주로 제너레이터의 종료를 처리하기 위해 사용됩니다.","def ex_generator():
    try:
        yield 1
        yield 2
        yield 3
    except GeneratorExit:
        print(""GeneratorExit Closed"")

gen = ex_generator()
print(next(gen))
print(next(gen))
gen.close()

결과값:
1
2
GeneratorExit Closed
"
ImportError,"ImportError는 import 문이 모듈을 로드하는 데 문제가 있을 때 발생하는 오류입니다.
다음과 같은 경우 ImportError가 발생할 수 있습니다.

1. 모듈이 설치되어 있지 않은 경우
2. 모듈 이름이 잘못된 경우
3. 모듈 경로가 잘못된 경우
4. 모듈의 종속성이 충족되지 않은 경우
5. 모듈 파일이 손상된 경우

ImportError가 발생할 시 오류 메시지에 자세한 정보가 포함되어 있습니다.
이 메시지를 통해 원인을 파악하고 문제를 해결할 수 있습니다.","# example : 함수 이름이 잘못된 경우
from math import sinn #함수 명 오타 (sinn : X, sin : O)

----> 1 from math import sinn

ImportError: cannot import name 'sinn' from 'math' (unknown location)"
ModuleNotFoundError,"ModuleNotFoundError는 파이썬에서 모듈을 찾을 수 없을 때 발생하는 예외입니다.
다음 같은 경우에 ModuleNotFoundError가 발생합니다

1. 모듈이 설치되어 있지 않은 경우
2. 모듈이 시스템 경로에 없는 경우
3. 모듈의 이름이 잘못된 경우
4. 모듈 파일이 손상된 경우

ModuleNotFoundError가 발생할 시 오류 메시지에 자세한 정보가 포함되어 있습니다.
이 메시지를 통해 원인을 파악하고 문제를 해결할 수 있습니다.","# example : 모듈 이름이 잘못된 경우
import mathh

----> 1 import mathh

ModuleNotFoundError: No module named 'mathh' "
IndexError,"IndexError는 인덱스가 시퀀스 범위를 벗어날 때 발생합니다.
Python에서 인덱스는 0부터 시작하기 때문에 유효한 인덱스 범위는 0부터 길이-1 입니다.
유효한 범위 내에 있는지 확인할 필요가 있습니다.","ex_list = [1, 2, 3, 4]

ex_list[4]

----> 3 ex_list[4]

IndexError: list index out of range"
KeyError,KeyError는 딕셔너리(dictionary)에 존재하지 않는 키를 사용하여 접근할 때 발생하는 오류입니다.,"ex_dict = {'a' : 1, 'b' : 2, 'c' : 3}
value = ex_dict['key']

----> 2 value = ex_dict['key']

KeyError: 'key' "
KeyboardInterrupt,"KeyboardInterrupt는 사용자가 키보드 입력 등을 통해 프로그램의 실행을 중지시키는 동작을 수행할 때 발생하는 예외입니다.
일반적으로 인터럽트 키(Control-C 또는 Delete)를 누르면 발생합니다.","while True:
    print('never ending...')

# 인터프리터 '정지' 버튼 클릭 (like Ctrl+C or Delete)

결과값:
      1 while True:
----> 2     print('never ending...')

KeyboardInterrupt: "
MemoryError,"MemoryError는 프로그램이 더 이상 메모리를 할당할 수 없을 때 발생하는 오류입니다.
이 오류는 시스템의 가용 메모리가 부족한 경우 또는 프로그램이 너무 많은 메모리를 사용하는 경우에 발생할 수 있습니다.
대부분의 경우, MemoryError는 시스템의 물리적인 메모리 제한에 의해 발생합니다.
따라서 메모리 사용을 최적화하거나, 더 많은 메모리를 사용할 수 있는 환경을 마련하여 해결할 수 있습니다.
다음은 메모리 사용을 최적화하기 위한 접근 방법입니다.

1. 불필요한 데이터 구조 또는 객체를 삭제한다.
2. 큰 데이터를 처리할 때 파일 기반의 처리 방식이나 제너레이터 등을 사용하여 메모리 사용량을 줄인다.
3. 데이터를 작은 덩어리로 나누어 작업한다.
4. 메모리 사용을 모니터링하여 메모리 누수가 발생하는 지 확인한다. 메모리 누수는 사용하지 않는 객체가 메모리에 계속 로드되는 등의 사유로 발생할 수 있습니다.

이 밖에 메모리 사용 환경을 원활하게 바꾸는 방법도 있습니다.

1. 시스템의 물리적인 메모리 용량을 늘립니다.
2. 대규모 데이터 처리에 특화된 서버 또는 클라우드 환경을 이용합니다.
3. 대용량 데이터 처리에 특화된 데이터베이스나 분산 처리 시스템을 사용합니다.",
NameError,"NameError는 변수 또는 함수 등의 이름이 정의되지 않은 경우에 발생하는 오류입니다.
NameError는 해당 이름이 포함된 코드를 다시 검토하고 문제가 발생하는 부분을 자세히 살펴보면서 해결해야 합니다.
NameError는 다음과 같은 경우에 발생할 수 있습니다.

1. 변수, 함수, 클래스 등의 이름이 올바르게 정의되지 않은 경우
2. 변수를 사용하기 전에 선언되지 않았거나 초기화되지 않은 경우
3. 함수 또는 클래스를 호출하기 전에 정의되지 않은 경우
4. import 되지 않은 모듈을 사용하려는 경우","example_sentence1 = 'Hello World!'

print(example_sentence2)

----> 3 print(example_sentence2)

NameError: name 'example_sentence2' is not defined"
UnboundLocalError,"UnboundLocalError는 로컬 변수가 선언되었지만 초기화 되지 않은 경우에 발생합니다.
로컬 단위에서 선언 후 지역 단위에서 수정하거나, 참조하는 등의 경우에 발생합니다.","x = 10

def ex_func():
    x = x + 10

ex_func()

----> 6 ex_func()

      3 def ex_func():
----> 4     x = x + 10

UnboundLocalError: local variable 'x' referenced before assignment"
RuntimeError,"RuntimeError는 Python 인터프리터가 번역한 명령어가 실행 도중에 에러가 나는 경우에 발생합니다.
오류 발생 조건이 일어났을 경우에만 발생하게 됩니다.
이는 문법적인 문제가 있어 발생하는 SyntaxError와 구분되는 개념입니다.",
Traceback,"Traceback은 파이썬에서 예외(에러)가 발생하였을 때 어느 부분에서 예외(에러)가 발생하였는 지 알려주는 부분입니다.
예외(에러)가 발생하면 호출 스택을 거슬러 올라가며 함수의 정보를 출력합니다.
예를 들어, cell 내에서 함수가 호출 된 경우 해당 함수 내부에서 어느 부분에서 예외(에러)가 발생하는 지 나타냅니다.","# Traceback 형식
Traceback (most recent call last)
    File ""파일이름"", ""줄 번호"", in ""함수이름""
        호출된 함수 코드
예외타입 : 예외메시지"
NotImplementedError,"NotImplementedError는 파이썬에서 사용되는 내장 예외 클래스입니다.
이 예외는 메서드나 함수가 구현되지 않았음을 나타내는데 사용됩니다.
일반적으로 추상 클래스나 추상 메서드를 정의할 때 사용되며, 해당 메서드가 파생 클래스에서 구현되어야 함을 나타냅니다.
다음과 같은 상황에서 NotImplementedError가 자주 사용될 수 있습니다.

1. 추상 클래스의 추상 메서드가 파생 클래스에서 구현되지 않은 경우
2. 상속받은 클래스에서 필요한 메서드를 재정의하지 않은 경우
3. 일부 기능이 아직 구현되지 않았거나 지원되지 않는 경우","class Animal:
    def sound(self):
        raise NotImplementedError(""Subclasses must implement the sound method"")

class Dog(Animal):
    def sound(self):
        return ""멍멍!""

class Cat(Animal):
    def sound(self):
        return ""냥냥!""

class Cow(Animal):
    pass

dog = Dog()
cat = Cat()
cow = Cow()

print(dog.sound())
print(cat.sound())
print(cow.sound())

결과값:
멍멍!
냥냥!

      2 def sound(self):
----> 3     raise NotImplementedError(""Subclasses must implement the sound method"")

NotImplementedError: Subclasses must implement the sound method
"
RecursionError,"RecursionError는 재귀 호출이 지나치게 깊어지면 발생하는 오류입니다.
이는 재귀 함수를 사용할 때 주로 발생합니다.
재귀 함수는 자기 자신을 호출하는 함수로서 동일한 작업을 반복적으로 수행하거나 문제를 분할하여 해결할 때 사용됩니다.
이러한 재귀 함수가 무한히 반복되거나 스택의 한계를 초과할 때 RecursionError가 발생할 수 있습니다.","def infinite_recursion(n):
    print(n)
    infinite_recursion(n + 1)

infinite_recursion(1)

결과값:
1
2
...
2997
2998
...

      2     print(n)
----> 3     infinite_recursion(n + 1)
RecursionError: maximum recursion depth exceeded while calling a Python object"
OSError,"OSError는 Python에서 발생하는 파일 또는 운영 체제와 관련된 오류를 나타내는 예외입니다.
OSError는 파일 작업, 디렉토리 조작 등 다양한 상황에서 발생할 수 있습니다.
",
OverflowError,OverflowError는 산술 연산의 결과값의 너무 크거나 표현 범위를 벗어나서 Python이 표현할 수 없을 때 발생합니다.,"# example : e^1000 을 계산하는 코드지만, 결과가 매우 큰 수이며 Python의 표현 범위를 벗어 나는 경우.
import math

x = math.exp(1000)
print(x)

결과값:
----> 3 x = math.exp(1000)
      4 print(x)

OverflowError: math range erro
"
ReferenceError,"ReferenceError는 변수가 정의되지 않았거나 유효하지 않은 변수에 접근할 때 발생하는 예외입니다.
즉, 변수가 존재하지 않는 경우에 발생합니다.
ReferenceError는 다음과 같은 상황에서 발생할 수 있습니다.

1. 정의되지 않은 변수에 접근
2. 유효하지 않은 변수에 접근
3. 삭제된 변수에 접근

하지만 Python에서는 ReferenceError가 사용되지 않으며 해당 내용에 따른 예외가 존재합니다.",
StopIteration,StopIteration은 이터레이터에 의해 생성된 항목이 더 없는 경우 발생합니다.,"def ex_generator():
    yield 1
    yield 2

gen = ex_generator()

print(next(gen)) # 1번째 출력
print(next(gen)) # 2번째 출력
print(next(gen)) # 3번째 출력

결과값:
      8 print(next(gen)) # 2번째 출력
----> 9 print(next(gen))

StopIteration: "
StopAsyncIteration,"StopAsyncIteration 예외는 비동기 이터레이터와 비동기 제너레이터에서 더 이상 반환할 요소가 없는 경우 발생합니다.
이 예외는 순회를 종료하는 신호로 사용됩니다.
StopAsyncIteration 예외는 비동기 이터레이터와 비동기 제너레이터에서 내부적으로 처리되므로, 일반적으로 사용자가 직접 다룰 필요가 없습니다.
파이썬의 비동기 프로그래밍 환경에서 자동으로 처리되는 예외입니다.","import asyncio

async def my_async_generator():
    yield 1
    yield 2
    yield 3

async def main():
    async for item in my_async_generator():
        print(item)
    raise StopAsyncIteration

await main()

결과값:
1
2
3

     10     print(item)
---> 11 raise StopAsyncIteration

StopAsyncIteration: 
"
SyntaxError,"SyntaxError는 Python 코드의 구문 오류를 나타내는 내장 예외입니다.
Python 코드에서 문법적인 오류(ex. 구문, 들여쓰기, 식별자 등)가 있을 경우 나타납니다.","print('Hello World!'

결과값:
    print('Hello World!'
                        ^
SyntaxError: incomplete input"
IndentationError,"IndentationError는 잘못된 들여쓰기와 관련된 문법 오류의 베이스 클래스입니다.
SyntaxError의 서브 클래스입니다.","def ex_TabError():
    print('Hello')
        print('World!')

ex_TabError()

결과값:
    print('Hello')
    ^
IndentationError: expected an indented block after function definition on line 1"
TabError,"TabError는 들여쓰기가 일관성없는 탭과 스페이스 사용을 포함하는 경우 발생합니다.
들여쓰기를 할 때, 탭 혹은 스페이스 4번으로 통일 시켜본다면 해결할 수 있습닌다.
IndentationError 의 서브 클래스입니다.",
SystemError,"SystemError는 Python 인터프리터 내부 에러를 나타내는 예외입니다.
일반적으로 Python 인터프리터나 라이브러리의 버그 혹은 시스템 환경 문제로 발생합니다.
SystemError는 다음과 같은 경우를 확인이 필요합니다.

1. Python 버전 확인 및 업데이트
2. 라이브러리 버전 확인 및 업데이트
3. 시스템 환경 검토","
"
SystemExit,"SystemExit는 Python 프로그램이 sys.exit() 함수를 호출하거나 메인 스크립트가 종료될 때 발생합니다.
sys.exit() 함수를 호출하면 현재 실행 중인 Python 프로그램이 종료되는데, SystemExit 예외 처리 부분이 있다면 그 부분으로 이동합니다.
일반적으로 SystemExit는 프로그램을 명시적으로 종료하는 데 사용됩니다.","import sys

def ex_function():
    if True:
        sys.exit()

try:
    ex_function()
except SystemExit:
    print('프로그램이 종료되었습니다.')"
TypeError,"TypeError는 Python에서 객체의 데이터 타입이 잘못되었거나, 연산이 지원되지 않는 데이터 타입 간에 이뤄질 때 발생합니다.
TypeError가 발생한다면 데이터 타입이 올바르게 되었는지, 확인 후 데이터 타입 변환을 통해 해결할 수 있습니다.","x = 'Hello'
y = 5

x + y

결과값:

----> 4 x + y

TypeError: can only concatenate str (not ""int"") to str"
ValueError,"ValueError는 Python에서 값이 적절하지 않은 경우에 발생하는 예외입니다.
다음과 같은 경우에 ValueError가 발생할 수 있습니다.

1. 함수에 적절하지 않은 형태의 인자가 전달될 때
2. 함수에 전달되는 인자의 값의 범위가 유효하지 않을 때
3. 변환할 수 없는 형태의 값을 변환하려고 할 때","# example : 변환할 수 없는 형태의 값을 변환하려고 할 때
number = int(""Hello"")

결과값:
----> 1 number = int(""Hello"")

ValueError: invalid literal for int() with base 10: 'Hello' "
UnicodeError,"UnicodeError는 Python 유니코드 관련 에러가 일어날 때 발생합니다.
다음과 같은 경우에 UnicodeError가 발생할 수 있습니다.

1. 잘못된 인코딩 : 유니코드 문자열을 다른 인코딩으로 변환하려고 할 때 발생할 수 있습니다.
2. 잘못된 디코딩 : 인코딩된 바이트를 유니코드 문자열로 디코딩하려고 할 때 발생할 수 있습니다.
3. 잘못된 유니코드 문자열 처리 : 유니코드 문자열의 조합, 분리, 정규화 등의 작업에서 오류가 생길 수 있습니다.",
UnicodeEncodeError,"UnicodeEncodeError는 인코딩 중 유니코드 관련 에러가 일어날 때 발생하며 UnicodeError 의 서브 클래스입니다.
UnicodeEncodeError는 유니코드 문자열을 특정 인코딩으로 변환할 수 없는 경우에 발생합니다.","# example : 한글은 ASCII 인코딩으로 표현할 수 없는 경우
text = ""안녕 세상!""
encoded_text = text.encode(""ascii"")

결과값:
----> 2 encoded_text = text.encode(""ascii"")

UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-4: ordinal not in range(128)
"
UnicodeDecodeError,"UnicodeDecodeError는 디코딩 중 유니코드 관련 에러가 일어날 때 발생하며 UnicodeError 의 서브 클래스입니다.
UnicodeDecodeError는 유니코드 문자열을 특정 인코딩으로 디코딩할 수 없는 경우에 발생합니다.","# example : 잘못된 UTF-8 인코딩된 byte 데이터를 UTF-8로 디코딩할 수 없는 경우
binary_data = b""í ½í¸""
decoded_text = binary_data.decode(""utf-8"")

결과값:
----> 2 decoded_text = binary_data.decode(""utf-8"")

UnicodeDecodeError: 'utf-8' codec can't decode byte 0xed in position 0: invalid continuation byte"
UnicodeTranslateError,"UnicodeTranslateError는 유니코드 문자열로 변환하는 과정에서 발생하며 UnicodeError 의 서브 클래스입니다.
UnicodeTranslateError는 유니코드 문자열을 특정 형식으로 변환할 수 없는 경우에 발생합니다.
UnicodeTranslateError는 일반적인 상황에서 자주 발생하지는 않습니다.
다만, 유니코드 관련 작업을 수행할 때 발생할 수 있습니다.
따라서 try-except 문을 사용하여 처리하는 방식으로 해결할 수 있습니다.","
"
LookupError,"LookupError는 Python에서 다양한 검색(lookup) 작업과 관련된 오류입니다.
LookupError는 다음과 같은 예외 클래스들의 베이스 클래스로 사용됩니다.

1. IndexError
2. KeyError
3. NameError","# IndexError: list index out of range
my_list = [1, 2, 3]
print(my_list[5])


# KeyError: 'x'
my_dict = {'a': 1, 'b': 2}
print(my_dict['x'])


# NameError: name 'x' is not defined
print(x)
"
ZeroDivisionError,"ZeroDivisionError는 어떤 수를 0으로 나누려고 할 때 발생합니다.
어떤 수를 0으로 나누는 수식은 수학적으로 정의되지 않는 연산이기 때문에 ZeroDivisionError 오류가 발생합니다.","print(example_zero = 99 / 0)

결과값:
----> 1 print(example_zero = 99 / 0)

ZeroDivisionError: division by zero"
WindowsError,"WindowsError는 이전 Python 버전에서 사용되면 예외 클래스로, 현재는 사용되지 않습니다.
현재는 OSError로 대체되었습니다.",
aiter,"비동기 이터레이터를 생성하기 위해 사용되는 함수입니다.
비동기 이터레이터는 async for 루프에서 사용되며, 비동기적으로 값을 생성하고 소비할 수 있는 방법을 제공합니다.","import asyncio

async def my_async_generator():
    yield 1
    yield 2
    yield 3

async def main():
    async for value in aiter(my_async_generator()):
        print(value)

await main()

결과값:
1
2
3"
awaitable anext,awaitable anext는 비동기 이터레이터에서 다음 값을 가져오는 함수입니다.,"import asyncio

async def my_async_generator():
    yield 1
    yield 2
    yield 3

async def main():
    async_gen = my_async_generator()
    value = await anext(async_gen)
    print(value)

    value = await anext(async_gen)
    print(value)

await main()

결과값:
1
2"
ascii,"ASCII는 American Standard Code for Information Interchange의 약어입니다.
ASCII는 영문 알파벳, 숫자, 특수 문자 등을 표현하기 위한 7비트 문자 인코딩 방식입니다.
ASCII는 일반적으로 사용되는 문자 인코딩 중 하나이며, 컴퓨터 시스템에서 텍스트를 표현하고 처리하는 데 사용됩니다.
Python에서는 ord(string)를 사용하여 문자를 ASCII 코드로, chr(int)을 사용하여 ASCII 코드를 문자로 변환할 수 있습니다.
다만, 한글은 지원하지 않습니다.","sentence = ""Hello World!""
ascii_code = ''
print('sentence : ', sentence)

for alpha in sentence:
    if ascii_code == '':
        ascii_code = str(ord(alpha))
    else:
        ascii_code = ascii_code + ' ' + str(ord(alpha))
print('string -> ASCII : ', ascii_code)

sentence_chr = ''
for asc in ascii_code.split(' '):
    sentence_chr = sentence_chr + chr(int(asc))
print('ASCII -> string : ', sentence_chr)

결과값:
sentence :  Hello World!
string -> ASCII :  72 101 108 108 111 32 87 111 114 108 100 33
ASCII -> string :  Hello World!"
bin,"bin() 함수는 정수를 이진수 문자열로 변환하는 내장 함수입니다.
bin() 함수는 정수를 “0b” 가 앞에 붙은 이진 문자열로 변환합니다.

","num = 10
binary = bin(num)
print(binary)

결과값:
0b1010"
breakpoint,"breakpoint() 함수는 디버깅을 위해 코드 실행을 중단하는 함수입니다.
breakpoint() 함수를 호출하면 프로그램 실행이 중지되고, 대화형 디버거로 전환됩니다.
","def calculate_sum(a, b):
    result = a + b
    breakpoint()  # 디버깅 지점
    return result

x = 10
y = 5
z = calculate_sum(x, y)
print(z)"
bytearray,"bytearray는 Python의 내장 클래스로서, 가변적인 바이트 배열을 나타냅니다.
bytearray 객체는 다양한 메서드를 제공하여 바이트 배열을 생성하고 수정할 수 있습니다.
다음은 bytearray의 주요한 메서드 목록입니다.

1. bytearray() 생성자: 빈 바이트 배열을 생성합니다.
2. bytearray(iterable) 생성자: iterable 객체로부터 바이트 배열을 생성합니다. 예를 들어, 문자열을 전달하여 문자열을 바이트로 변환할 수 있습니다.
3. bytearray(bytes) 생성자: bytes 객체로부터 바이트 배열을 생성합니다.
4. bytearray.decode(encoding, errors) 메서드: 바이트 배열을 문자열로 디코딩합니다.
5. bytearray.append(value) 메서드: 바이트 배열에 새로운 값을 추가합니다.
6. bytearray.extend(iterable) 메서드: iterable 객체의 값들을 바이트 배열에 추가합니다.
7. bytearray.pop(index=-1) 메서드: 지정된 인덱스에 해당하는 바이트를 제거하고 반환합니다.","data = bytearray([65, 80, 80, 76, 69])
decoded = data.decode('utf-8')
print(decoded)

결과값:
APPLE"
bytes,"bytes는 Python 내장 클래스로서, 0 부터 255 까지의 정수값을 가지는 불변의 바이트 시퀀스로 구성됩니다.
bytes는 불변성을 가지기 때문에 한 번 생성된 후에는 변경, 추가 등의 수정 작업이 불가능합니다.
하지만, 인덱싱과 슬라이싱을 통해 원하는 바이트에 접근은 가능합니다.
bytes 객체는 주로 이진 데이터 처리 또는 네트워크 통신에서 사용될 수 있으며, 불변성을 가지므로 안전하게 공유할 수 있습니다.","data = bytes([65, 80, 80, 76, 69])
print(data)

decoded = data.decode('utf-8')
print(decoded)

결과값:
b'APPLE'
APPLE
"
callable,"callable 함수는 인자로 전달된 객체가 호출이 가능한지 여부를 확인하는 함수입니다.
호출 가능한 객체는 함수, 메서드, 클래스 등을 포함합니다.
callable 함수는 객체 호출이 가능한 경우 'True' 를 반환하고 호출이 불가능 한 경우에는 'False'를 반환합니다.","class ex_Class:
    def ex_function(self):
        print('Hello, World!')
    
ex_object = ex_Class()

print(callable(ex_function))
print(callable(ex_Class))
print(callable(ex_object))

결과값:
True
True
False"
chr,"chr() 함수는 정수(inteager)형 매개변수를 받아서 해당하는 유니코드 문자를 반환합니다.
chr()함수는 ord()함수와 반대되는 개념입니다.","print(chr(97))

결과값:
a"
ord,"ord() 함수는 유니코드 문자를 받아서 해당하는 유니코드 코드 포인트를 정수형으로 반환합니다.
ord()함수는 chr()함수와 반대되는 개념입니다.","print(ord('A'))

결과값:
65"
@classmethod,"@classmethod는 Python에서 사용되는 데코레이터(decorator)입니다.
@classmethod로 정의된 메서드는 클래스 메서드로 동작합니다.

클래스 메서드는 클래스 레벨에서 호출할 수 있는 메서드로, 인스턴스에 속한 것이 아니라 클래스 자체에 속합니다.
클래스 메서드는 첫 번째 매개변수로 클래스 자신을 나타내는 cls를 받습니다.
이 cls 매개변수를 통해 클래스 속성에 접근하고 조작할 수 있습니다.

클래스 메서드는 인스턴스 변수에 의존하지 않고 클래스 자체의 상태나 동작을 다룰 때 사용됩니다.
또한, 서브클래스에서 오버라이딩 할 수 있는 메서드를 제공할 때 유용하게 활용됩니다.","class ex_Class:
    @classmethod
    def ex_class_method(cls, arg1, arg2):
        # 클래스 메서드 구현

# 클래스 메서드 호출
ex_Class.ex_class_method(arg1, arg2)"
compile,"compile은 파이썬 코드를 컴파일하여 코드 객체를 생성하는 내장 함수입니다.
compile 함수는 문자열 형태로 된 파이썬 코드를 인자로 받고, 해당 코드를 컴파일하여 실행 가능한 코드 객체를 반환합니다.
compile 함수는 동적인 코드 생성이나 실행 가능한 코드 문자열을 다룰 때 사용될 수 있습니다.
compile 함수는 다음과 같은 구조를 가집니다.

compile(source, filename, mode)
    1. source: 컴파일할 파이썬 코드를 나타내는 문자열입니다.
    2. filename: 컴파일된 코드의 파일명을 나타내는 문자열입니다.
    3. mode: 컴파일 모드를 나타내는 문자열입니다. 주로 ""exec"", ""eval"", ""single"" 중 하나를 사용합니다.","code = compile(""print('Hello, world!'), ""<string>"", ""exec"")
exec(code)

결과값:
Hello, world!"
complex,"complex 함수는 Python에서 복소수를 나타내는 데 사용됩니다.
complex를 사용하는 형식은 다음과 같습니다.

1. complex(real, imag) : 실수 부분을 나타내는 real 부분과 허수 부분을 나타내는 imag 부분을 정수 값으로 받아 복소수를 생성합닌다.
2. complex(string) : 생성할 복소수를 문자열로 나타낸 요소를 받아 생성합니다.","print(complex(2, 3))
print(complex(""2+3j""))
print(complex(2, 3) == complex(""2+3j""))

결과값:
2+3j
2+3j
True"
delattr,"delattr 함수는 파이썬의 내장 함수로, 객체의 속성(attribute)을 삭제하는 데 사용됩니다.","class ExClass:
    def __init__(self):
        self.attribute = ""Hello""

obj = ExClass()
print(obj.attribute)

delattr(obj, ""attribute"")
print(obj.attribute)

결과값:
Hello

      8 delattr(obj, ""attribute"")
----> 9 print(obj.attribute)

AttributeError: 'ExClass' object has no attribute 'attribute' "
dir,dir 함수는 객체가 가지고 있는 속성과 메서드의 리스트를 반환합니다.,"import math
print(dir(math))

결과값:
['__doc__',
 '__loader__',
 ...
  'trunc',
 'ulp']"
getattr,"getattr 함수는 객체에서 속성(attribute) 값을 가져오는 역할을 합니다.
getattr 함수는 다음과 같은 형식을 가집니다.

getattr(object, name, default)
- object : 값을 가져올 객체
- name : 가져올 속성의 이름
- default : 속성이 존재하지 않을 경우 반환할 기본값입니다. 기본값을 지정하지 않으면 속성이 존재하지 않을 때 'AttributeError'가 발생합니다.","class Ex_Class:
    def __init__(self):
        self.X = ""Hello""

ttt = Ex_Class()

print(getattr(ttt, 'X'))
print(getattr(ttt, 'Y', 'None'))
print(getattr(ttt, 'Y'))

결과값:
Hello
None

      7 print(getattr(ttt, 'X'))
      8 print(getattr(ttt, 'Y', 'None'))
----> 9 print(getattr(ttt, 'Y'))

AttributeError: 'Ex_Class' object has no attribute 'Y' "
divmod,divmod 함수는 두 개의 숫자를 인자로 받아서 몫과 나머지를 함께 반환합니다.,"result = divmod(10, 3)
print(result)

결과값:
(3, 1)"
eval,"eval 함수는 문자열로 표현된 Python 표현식을 실행하여 결과를 반환합니다.
eval 함수는 다음과 같은 구조를 가집니다.

eval(expression, globals=None, locals=None)

- expression : 실행할 Python 코드를 나타내는 문자열입니다.
- globals : 전역 이름 공간을 나타내는 딕셔너리입니다. 기본값은 현재 전역 이름 공간입니다.
- locals : 지역 이름 공간을 나타내는 딕셔너리입니다. 기본값은 현재 지역 이름 공간입니다.","x = 10
result = eval('x + 5')
print(result)

결과값:
15"
exec,"exec 함수는 Python의 내장 함수로, 문자열로 표현된 파이썬 코드를 실행합니다.
eval 함수와 비슷한 역할을 하지만 eval 함수는 실행 및 결과 반환을 하는 반면, exec 함수는 결과를 반환하지 않고 실행만 합니다.
exec 함수는 다음과 같은 구조를 가집니다.

exec(source, globals=None, locals=None)

- source : 실행할 Python 코드를 나타내는 문자열입니다.
- globals : 전역 이름 공간을 나타내는 딕셔너리입니다. 기본값은 현재 전역 이름 공간입니다.
- locals : 지역 이름 공간을 나타내는 딕셔너리입니다. 기본값은 현재 지역 이름 공간입니다.","
"
filter,"filter 함수는 주어진 함수를 이용하여 이터러블(iterable) 객체에서 원하는 요소만을 걸러내는 역할을 합니다.
다음은 filter 함수의 구조입니다.

filter(function, iterable)

- function : 걸러낼 요소를 판별하기 위해 호출되는 함수입니다. 함수는 True 혹은 False 를 반환해야 합니다.
- iterable : 걸러내고자 하는 요소들이 포함된 이터러블(iterable)객체입니다.","def is_even(num):
    return num % 2 == 0

number_list = [1, 2, 3, 4]
even_numbers = list(filter(is_even, number_list))
print(even_numbers)

결과값:
[2, 4]"
format,"format 은 문자열을 포맷팅하는 역할을 합니다.
format 함수는 문자열 내에 중괄호({})를 사용하여 변수나 값을 삽입하고, 해당 중괄호에 대응하는 값을 대체하는 방식으로 동작합니다.
format 함수는 다음과 같은 형식으로 사용됩니다.

format_string = ""string"".format(value, format_spec)
- value : 포맷팅할 값을 나타내는 변수
- format_spec : 포맷팅의 형식을 지정하는 옵션으로, 생략 가능합니다.","name = ""John""
age = 28

ex_sentence = ""My name is {} and I am {} years old"".format(name, age)
print(ex_sentence)

결과값
My name is John and I am 28 years old"
frozenset,"frozenset은 집합(set)과 유사한 동작을 하며, 중복되지 않는 항목들의 모음을 저장할 수 있습니다.
하지만 frozenset은 한 번 생성되면 내부 요소를 변경할 수 없기 때문에 불변성을 가집니다.
frozenset은 이터러블(iterable)객체를 받아서 만들어집니다.
frozenset의 주요 특징은 다음과 같습니다.

1. 불변성
2. 중복 요소 제거
3. 순서 없음","
"
globals,globals 함수는 현재 전역 심볼 테이블을 나타내는 딕셔너리를 반환합니다.,"globals()

결과값:
{'__name__':'__main__', ...}"
hasattr,"hasattr 함수는 객체가 특정 속성(attribute)을 가지고 있는지 확인하는 파이썬의 내장 함수입니다.
주어진 객체가 지정된 이름의 속성ㅇ르 가지고 있는 경우 'True'를 반환하고, 속성을 가지고 있지 않거나 접근할 수 없는 경우 'False'를 반환합니다.
hasattr 함수는 다음과 같은 형식으로 사용됩니다.

hasattr(object, name)
- object : 속성을 확인할 객체
- name : 확인할 속성의 이름(string)","class Ex_Class:
    def __init__(self, name):
        self.name = name

obj = Ex_Class(""John"")

print(hasattr(obj, ""name""))
print(hasattr(obj, ""age""))

결과값:
True
False"
hash,"hash 함수는 주어진 객체의 해시 값을 반환하는 Python 함수입니다.
해시 값은 임의의 크기를 가지는 정수로, 객체의 내용을 고유하게 대표합니다.
hash 함수는 불변한 객체에 대해서만 유효하며, 가변 객체에 대해서는 호출할 수 없습니다.
또한 hash 함수의 반환 값은 실행할 때 마다 다를 수 있으며, 해시 충돌의 가능성이 있습니다.","print(hash(""Hello""))
print(hash(42))

결과값:
9157133087770006655
42
"
help,"help 함수는 파이썬의 내장 도움말 시스템을 사용하여 객체나 모듈에 대한 도움말 정보를 제공합니다.
help 함수는 다음과 같은 형식으로 사용됩니다.

help(object)
- object : 도움말을 조회할 객체 또는 모듈","import math
help(math)"
hex,hex함수는 정수를 “0x” 접두사가 붙은 소문자 16진수 문자열로 변환합니다.,"print(hex(42))

결과값:
0x2a"
id,id 함수는 Python 객체의 고유 식별자(unique identifier)를 반환하는 내장 함수입니다.,"str1 = ""Hello""
str2 = ""Hello""
str3 = ""Hallo""
print(id(str1))
print(id(str2))
print(id(str3))

결과값:
3040018984688
3040018984688
3040019096496"
isinstance,"isinstance 함수는 주어진 객체가 특정 클래스의 인스턴스인지를 확인하는 내장 함수입니다.
isinstance 함수는 객체와 클래스를 비교하여 객체가 해당 클래스의 인스턴스인 경우 True를, 아니라면 False를 반환합니다.","print(isinstance(""Hello"", int))

결과값:
False"
issubclass,"issubclass 함수는 Python에서 클래스의 상속 관계를 확인하는 내장 함수입니다.
이 함수는 주어진 클래스가 다른 클래스의 서브클래스인지를 판별하여 True 또는 False를 반환합니다.","class A:
    pass

class B(A):
    pass

print(issubclass(B, A))
print(issubclass(A, B))

결과값:
True
False"
iter,"iter는 Python의 내장 함수 중 하나로, 반복 가능한 객체(iterable)를 받아 이터레이터(iterator)를 반환합니다.
iter 함수의 구문은 다음과 같습니다.

iter(iterable, sentinel)
- iterable: 반복 가능한 객체입니다. 이터레이터를 생성할 객체입니다.
- sentinel (옵션): 선택적으로 지정할 수 있는 매개변수입니다. 이터레이터를 종료시키기 위한 종료 조건을 나타내는 값을 지정할 수 있습니다. sentinel 값을 지정하지 않으면 기본적으로 iterable 객체의 끝까지 반복합니다.
","my_list = [1, 2, 3, 4, 5]
my_iter = iter(my_list)
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))

결과값:
1
2
3"
locals,"현재 지역 심볼 테이블을 나타내는 딕셔너리를 갱신하고 돌려줍니다.
모듈 수준에서 locals()와 globals()는 같은 딕셔너리임에 유의하세요.","locals()

결과값:
{'__name__':'__main__', ...}"
memoryview,"지정된 인자로부터 만들어진 “메모리 뷰” 객체를 돌려줍니다.
이를 통해 Python에서 데이터의 메모리를 직접 조작할 수 있습니다.","ex_data = b""Hello, World!""
view = memoryview(ex_data)
print(view[0])

결과값:
72"
next,next 함수는 이터레이터(iterator)객체에서 다음 값을 가져오는 역할을 합니다.,"my_list = [1, 2, 3, 4, 5]
my_iterator = iter(my_list)

print(next(my_iterator))
print(next(my_iterator))
print(next(my_iterator))

결과값:
1
2
3"
object,"object(객체)는 프로그래밍에서 데이터와 그 데이터를 조작하는 함수들을 하나로 묶어서 다루는 개념입니다.
object(객체)는 클래스(Class)를 기반으로 생성됩니다.","
"
oct,oct 함수는 정수를 “0o”로 시작하는 8진수 문자열로 변환합니다.,"print(oct(42))

결과값:
0o52"
pow,"pow 함수는 하나의 숫자를 다른 숫자의 거듭제곱으로 계산하는 기능을 제공합니다.
pow(x, y) 형태로 사용되며, x를 y번 거듭제곱한 값을 반환합니다.","print(pow(2, 3))

결과값:
8"
@property,"@property는 Python에서 속성에 대한 접근과 설정을 컨트를하기 위한 내장 데코레이터입니다.
일반적으로 클래스의 속성은 직접적으로 접근 가능하며, obj.attribute와 같은 형태로 값을 가져오거나 설정할 수 있습니다.
그러나 property를 사용하면 속성을 메서드로 감싸고, 속성에 접근하는 동작을 추가적인 로직을 수행하도록 커스터마이즈할 수 있습니다.
property를 정의하기 위해 다음 세 가지 메서드를 활용합니다:

1. getter: 속성 값을 반환하는 메서드를 정의합니다.
2. setter: 속성 값을 설정하는 메서드를 정의합니다.
3. deleter: 속성을 삭제하는 메서드를 정의합니다.","class Circle:
    def __init__(self, radius):
        self.radius = radius

    @property
    def area(self):
        return 3.14 * self.radius ** 2

circle = Circle(3)
print(circle.area)

결과값:
28.26"
repr,"repr은 Python 내장 함수로, 객체의 ""official"" 또는 ""표현적인"" 문자열 표현을 반환하는 기능을 제공합니다.
repr(object) 형태로 사용되며, object의 __repr__() 메서드를 호출하여 해당 문자열을 얻습니다.
","class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f""Point({self.x}, {self.y})""

p = Point(1, 2)
print(repr(p))

결과값:
Point(1, 2)"
reversed,"reversed()는 Python 내장 함수로, 시퀀스(sequence)를 역순으로 반복하는 기능을 제공합니다.
reversed(sequence) 형태로 사용되며, sequence의 역순을 나타내는 반복 가능한 객체(iterator)를 반환합니다.","numbers = [1, 2, 3]

for num in reversed(numbers):
    print(num)

결과값:
3
2
1"
round,round()는 숫자를 가장 가까운 정수 또는 지정된 소수 자릿수로 반올림하는 기능을 제공합니다.,"print(round(3.141592))
print(round(3.141592, 2))

결과값:
3
3.14"
setattr,"setattr 함수는 객체의 속성을 동적으로 설정하는 기능을 제공합니다.
setattr(object, name, value) 형태로 사용되며, object는 속성을 설정할 객체를 나타내고, name은 설정할 속성의 이름, value는 설정할 속성의 값을 의미합니다.","class Person:
    pass

person = Person()

setattr(person, 'name', 'John')
setattr(person, 'age', 25)

print(person.name)
print(person.age)

결과값:
John
25"
@staticmethod,"@staticmethod는 Python에서 사용되는 데코레이터(decorator) 중 하나로, 클래스 내에 정의된 메서드를 정적(static) 메서드로 변환합니다.
정적 메서드는 클래스의 인스턴스 없이 직접 클래스에서 호출할 수 있는 메서드입니다.
따라서 정적 메서드는 클래스의 인스턴스와 상태에 의존하지 않고, 독립적인 기능을 수행합니다.
","class MathUtils:
    @staticmethod
    def add(x, y):
        return x + y

result = MathUtils.add(3, 4)
print(result)

결과값:
7"
super,"super() 함수는 상위 클래스(superclass)에 대한 메서드 호출을 가능하게 합니다.
super() 함수를 사용하여 상위 클래스의 메서드를 호출하면, 현재 클래스의 인스턴스를 기반으로 상위 클래스의 메서드가 실행됩니다.
super() 함수의 형식은 다음과 같습니다.

class super(SubClass, self or object)
- SubClass : 현재 클래스의 이름을 나타냅니다.
- self : 현재 클래스의 인스턴스를 참조합니다. 이 형식을 사용하면 현재 클래스의 메서드에서 상위 클래스의 메서드를 호출할 수 있습니다.
- object : 현재 클래스의 인스턴스가 아닌 다른 객체를 참조합니다. 이 형식을 사용하여 현재 클래스가 아닌 다른 클래스의 메서드에서 상위 클래스의 메서드를 호출할 수 있습니다.","class Parent:
    def greet(self):
        print(""Hello from Parent"")

class Child(Parent):
    def greet(self):
        super().greet()
        print(""Hello from Child"")

child = Child()
child.greet()

결과값:
Hello from Parent
Hello from Child"
import,"import는 Python에서 모듈(Module)이나 패키지(package)를 가져오는ㄷ네 사용되는 키워드입니다.
import 문을 사용하는 방법은 다음과 같습니다.

1. 단일 모듈 또는 패키지 전체를 가져오기
2. 특정 요소만 가져오기
3. 모듈 또는 패키지를 별칭으로 가져오기","# example_1 : 전체 가져오기
import math

# example_2 : 일부 가져오기
from math import sqrt

# example_3 : 별칭으로 가져오기
import math as soohack"
Unicode,"Unicode는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하기 위한 표준 인코딩 시스템입니다.
Unicode는 문자를 코드 포인트(code point)라고 하는 고유한 숫자 값으로 매핑합니다.
이러한 코드 포인트는 16진수로 표현됩니다.","
unicode_str = ""안녕하세요""
encoded_str = unicode_str.encode('utf-8')
print(encoded_str)

결과값:
b'ìëíì¸ì' "
Key,"Key는 Python에서 주로 딕셔너리(Dictionary) 데이터 구조에서 사용되는 용어입니다.
딕셔너리는 키(Key)와 값(Value)으로 이루어진 데이터를 저장하고 관리합니다.
키(Key)는 변경할 수 없는 데이터 타입이어야 합니다.","# Dictionary 구조
ex_dict = {'Key' : 'Value'}"
Value,"Key는 Python에서 주로 딕셔너리(Dictionary) 데이터 구조에서 사용되는 용어입니다.
딕셔너리는 키(Key)와 값(Value)으로 이루어진 데이터를 저장하고 관리합니다.
값(Value)은 변경 가능한 데이터 타입이므로, 딕셔너리 내의 값을 수정하거나 업데이트할 수 있습니다.","# Dictionary 구조
ex_dict = {'Key' : 'Value'}"
index,"index는 여러 데이터 구조에서 사용되는 용어입니다.
index는 데이터 구조에서 특정 요소의 위치나 색인을 나타내는 데 사용됩니다.
다음은 index가 사용되는 예시입니다.

1. 리스트(List)의 인덱스
2. 문자열(String)의 인덱스
3. 데이터프레임(DataFrame)의 인덱스

이 밖에도 여러 데이터 구조에서 index가 사용됩니다.","import pandas as pd

# example_1 : 리스트(List)의 인덱스
ex_list = [1, 2, 3]
print(ex_list[1])

# example_2 : 문자열(String)의 인덱스
ex_string = ""Hello World!""
print(ex_string)

# example_3 : 데이터프레임(DataFrame)의 인덱스
ex_data = {'Name' : ['Jone', 'Jane'], 'Age' : [30, 20]}
df = pd.DataFrame(ex_data)
print(list(df.loc[0]))

결과값:
2
Hello World!
['Jone', 30]"
row,"row는 데이터 테이블에서 가로 방향으로 구성된 데이터의 단위를 의미합니다.
row는 데이터 테이블에서 행(row) 부분을 칭합니다.
행(row) 인덱스(index)를 사용하여 특정 행에 접근하거나 조작할 수 있습니다.","import pandas as pd

ex_data = {'Name' : ['Jone', 'Jane'], 'Age' : [30, 20]}
df = pd.DataFrame(ex_data)

row_0 = df.loc[0]
print(row_0)

결과값:
Name    Jone
Age       30
Name: 0, dtype: object"
column,"column은 데이터 테이블에서 세로 방향으로 구성된 데이터의 단위를 의미합니다.
column은 데이터 테이블에서 열(column) 부분을 칭합니다.
열 이름을 사용하여 특정 열에 접근하거나 조작할 수 있습니다.","import pandas as pd

ex_data = {'Name' : ['Jone', 'Jane'], 'Age' : [30, 20]}
df = pd.DataFrame(ex_data)

name_column = df['Name']
print(name_column)

결과값:
0    Jone
1    Jane
Name: Name, dtype: object"
